<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bower_components\d3-cloud\lib\d3\d3.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/fabric.BaseBrush.html">fabric.BaseBrush</a></li>
                                <li><a href="../classes/fabric.Canvas.html">fabric.Canvas</a></li>
                                <li><a href="../classes/fabric.Circle.html">fabric.Circle</a></li>
                                <li><a href="../classes/fabric.CircleBrush.html">fabric.CircleBrush</a></li>
                                <li><a href="../classes/fabric.Color.html">fabric.Color</a></li>
                                <li><a href="../classes/fabric.Element.html">fabric.Element</a></li>
                                <li><a href="../classes/fabric.Ellipse.html">fabric.Ellipse</a></li>
                                <li><a href="../classes/fabric.Gradient.html">fabric.Gradient</a></li>
                                <li><a href="../classes/fabric.Group.html">fabric.Group</a></li>
                                <li><a href="../classes/fabric.Image.filters.BaseFilter.html">fabric.Image.filters.BaseFilter</a></li>
                                <li><a href="../classes/fabric.Image.filters.Brightness.html">fabric.Image.filters.Brightness</a></li>
                                <li><a href="../classes/fabric.Image.filters.Convolute.html">fabric.Image.filters.Convolute</a></li>
                                <li><a href="../classes/fabric.Image.filters.Creates an instance of a PdfPrinter which turns document definition into a pdf.html">fabric.Image.filters.Creates an instance of a PdfPrinter which turns document definition into a pdf</a></li>
                                <li><a href="../classes/fabric.Image.filters.fabric.Image.html">fabric.Image.filters.fabric.Image</a></li>
                                <li><a href="../classes/fabric.Image.filters.fabric.Image.filter.Blend.html">fabric.Image.filters.fabric.Image.filter.Blend</a></li>
                                <li><a href="../classes/fabric.Image.filters.fabric.IText.html">fabric.Image.filters.fabric.IText</a></li>
                                <li><a href="../classes/fabric.Image.filters.fabric.Text.html">fabric.Image.filters.fabric.Text</a></li>
                                <li><a href="../classes/fabric.Image.filters.GradientTransparency.html">fabric.Image.filters.GradientTransparency</a></li>
                                <li><a href="../classes/fabric.Image.filters.Grayscale.html">fabric.Image.filters.Grayscale</a></li>
                                <li><a href="../classes/fabric.Image.filters.Invert.html">fabric.Image.filters.Invert</a></li>
                                <li><a href="../classes/fabric.Image.filters.Mask.html">fabric.Image.filters.Mask</a></li>
                                <li><a href="../classes/fabric.Image.filters.Multiply.html">fabric.Image.filters.Multiply</a></li>
                                <li><a href="../classes/fabric.Image.filters.Noise.html">fabric.Image.filters.Noise</a></li>
                                <li><a href="../classes/fabric.Image.filters.Pixelate.html">fabric.Image.filters.Pixelate</a></li>
                                <li><a href="../classes/fabric.Image.filters.RemoveWhite.html">fabric.Image.filters.RemoveWhite</a></li>
                                <li><a href="../classes/fabric.Image.filters.Resize.html">fabric.Image.filters.Resize</a></li>
                                <li><a href="../classes/fabric.Image.filters.Sepia.html">fabric.Image.filters.Sepia</a></li>
                                <li><a href="../classes/fabric.Image.filters.Sepia2.html">fabric.Image.filters.Sepia2</a></li>
                                <li><a href="../classes/fabric.Image.filters.Tint.html">fabric.Image.filters.Tint</a></li>
                                <li><a href="../classes/fabric.Intersection.html">fabric.Intersection</a></li>
                                <li><a href="../classes/fabric.Line.html">fabric.Line</a></li>
                                <li><a href="../classes/fabric.Object.html">fabric.Object</a></li>
                                <li><a href="../classes/fabric.Path.html">fabric.Path</a></li>
                                <li><a href="../classes/fabric.PathGroup.html">fabric.PathGroup</a></li>
                                <li><a href="../classes/fabric.Pattern.html">fabric.Pattern</a></li>
                                <li><a href="../classes/fabric.PatternBrush.html">fabric.PatternBrush</a></li>
                                <li><a href="../classes/fabric.PencilBrush.html">fabric.PencilBrush</a></li>
                                <li><a href="../classes/fabric.Point.html">fabric.Point</a></li>
                                <li><a href="../classes/fabric.Polygon.html">fabric.Polygon</a></li>
                                <li><a href="../classes/fabric.Polyline.html">fabric.Polyline</a></li>
                                <li><a href="../classes/fabric.Rect.html">fabric.Rect</a></li>
                                <li><a href="../classes/fabric.Shadow.html">fabric.Shadow</a></li>
                                <li><a href="../classes/fabric.SprayBrush.html">fabric.SprayBrush</a></li>
                                <li><a href="../classes/fabric.StaticCanvas.html">fabric.StaticCanvas</a></li>
                                <li><a href="../classes/fabric.Triangle.html">fabric.Triangle</a></li>
                                <li><a href="../classes/google/Area.html">google/Area</a></li>
                                <li><a href="../classes/google/Bar.html">google/Bar</a></li>
                                <li><a href="../classes/google/Common.html">google/Common</a></li>
                                <li><a href="../classes/google/CommonND.html">google/CommonND</a></li>
                                <li><a href="../classes/jsPDF.html">jsPDF</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/google_Area.html">google/Area</a></li>
                                <li><a href="../modules/google_Bar.html">google/Bar</a></li>
                                <li><a href="../modules/google_Common.html">google/Common</a></li>
                                <li><a href="../modules/google_CommonND.html">google/CommonND</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: bower_components\d3-cloud\lib\d3\d3.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(){if (!Date.now) Date.now = function() {
  return +new Date;
};
try {
  document.createElement(&quot;div&quot;).style.setProperty(&quot;opacity&quot;, 0, &quot;&quot;);
} catch (error) {
  var d3_style_prototype = CSSStyleDeclaration.prototype,
      d3_style_setProperty = d3_style_prototype.setProperty;
  d3_style_prototype.setProperty = function(name, value, priority) {
    d3_style_setProperty.call(this, name, value + &quot;&quot;, priority);
  };
}
d3 = {version: &quot;2.7.4&quot;}; // semver
var d3_array = d3_arraySlice; // conversion for NodeLists

function d3_arrayCopy(pseudoarray) {
  var i = -1, n = pseudoarray.length, array = [];
  while (++i &lt; n) array.push(pseudoarray[i]);
  return array;
}

function d3_arraySlice(pseudoarray) {
  return Array.prototype.slice.call(pseudoarray);
}

try {
  d3_array(document.documentElement.childNodes)[0].nodeType;
} catch(e) {
  d3_array = d3_arrayCopy;
}

var d3_arraySubclass = [].__proto__?

// Until ECMAScript supports array subclassing, prototype injection works well.
function(array, prototype) {
  array.__proto__ = prototype;
}:

// And if your browser doesn&#x27;t support __proto__, we&#x27;ll use direct extension.
function(array, prototype) {
  for (var property in prototype) array[property] = prototype[property];
};
function d3_this() {
  return this;
}
d3.functor = function(v) {
  return typeof v === &quot;function&quot; ? v : function() { return v; };
};
// Copies a variable number of methods from source to target.
d3.rebind = function(target, source) {
  var i = 1, n = arguments.length, method;
  while (++i &lt; n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
  return target;
};

// Method is assumed to be a standard D3 getter-setter:
// If passed with no arguments, gets the value.
// If passed with arguments, sets the value and returns the target.
function d3_rebind(target, source, method) {
  return function() {
    var value = method.apply(source, arguments);
    return arguments.length ? target : value;
  };
}
d3.ascending = function(a, b) {
  return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN;
};
d3.descending = function(a, b) {
  return b &lt; a ? -1 : b &gt; a ? 1 : b &gt;= a ? 0 : NaN;
};
d3.mean = function(array, f) {
  var n = array.length,
      a,
      m = 0,
      i = -1,
      j = 0;
  if (arguments.length === 1) {
    while (++i &lt; n) if (d3_number(a = array[i])) m += (a - m) / ++j;
  } else {
    while (++i &lt; n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
  }
  return j ? m : undefined;
};
d3.median = function(array, f) {
  if (arguments.length &gt; 1) array = array.map(f);
  array = array.filter(d3_number);
  return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
};
d3.min = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i &lt; n &amp;&amp; ((a = array[i]) == null || a != a)) a = undefined;
    while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; a &gt; b) a = b;
  } else {
    while (++i &lt; n &amp;&amp; ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; a &gt; b) a = b;
  }
  return a;
};
d3.max = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i &lt; n &amp;&amp; ((a = array[i]) == null || a != a)) a = undefined;
    while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt; a) a = b;
  } else {
    while (++i &lt; n &amp;&amp; ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt; a) a = b;
  }
  return a;
};
d3.extent = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b,
      c;
  if (arguments.length === 1) {
    while (++i &lt; n &amp;&amp; ((a = c = array[i]) == null || a != a)) a = c = undefined;
    while (++i &lt; n) if ((b = array[i]) != null) {
      if (a &gt; b) a = b;
      if (c &lt; b) c = b;
    }
  } else {
    while (++i &lt; n &amp;&amp; ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null) {
      if (a &gt; b) a = b;
      if (c &lt; b) c = b;
    }
  }
  return [a, c];
};
d3.random = {
  normal: function(mean, deviation) {
    if (arguments.length &lt; 2) deviation = 1;
    if (arguments.length &lt; 1) mean = 0;
    return function() {
      var x, y, r;
      do {
        x = Math.random() * 2 - 1;
        y = Math.random() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r &gt; 1);
      return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
};
function d3_number(x) {
  return x != null &amp;&amp; !isNaN(x);
}
d3.sum = function(array, f) {
  var s = 0,
      n = array.length,
      a,
      i = -1;

  if (arguments.length === 1) {
    while (++i &lt; n) if (!isNaN(a = +array[i])) s += a;
  } else {
    while (++i &lt; n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
  }

  return s;
};
// R-7 per &lt;http://en.wikipedia.org/wiki/Quantile&gt;
d3.quantile = function(values, p) {
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = values[h - 1],
      e = H - h;
  return e ? v + e * (values[h] - v) : v;
};
d3.transpose = function(matrix) {
  return d3.zip.apply(d3, matrix);
};
d3.zip = function() {
  if (!(n = arguments.length)) return [];
  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i &lt; m;) {
    for (var j = -1, n, zip = zips[i] = new Array(n); ++j &lt; n;) {
      zip[j] = arguments[j][i];
    }
  }
  return zips;
};

function d3_zipLength(d) {
  return d.length;
}
// Locate the insertion point for x in a to maintain sorted order. The
// arguments lo and hi may be used to specify a subset of the array which should
// be considered; by default the entire array is used. If x is already present
// in a, the insertion point will be before (to the left of) any existing
// entries. The return value is suitable for use as the first argument to
// &#x60;array.splice&#x60; assuming that a is already sorted.
//
// The returned insertion point i partitions the array a into two halves so that
// all v &lt; x for v in a[lo:i] for the left side and all v &gt;= x for v in a[i:hi]
// for the right side.
d3.bisectLeft = function(a, x, lo, hi) {
  if (arguments.length &lt; 3) lo = 0;
  if (arguments.length &lt; 4) hi = a.length;
  while (lo &lt; hi) {
    var mid = (lo + hi) &gt;&gt; 1;
    if (a[mid] &lt; x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
};

// Similar to bisectLeft, but returns an insertion point which comes after (to
// the right of) any existing entries of x in a.
//
// The returned insertion point i partitions the array into two halves so that
// all v &lt;= x for v in a[lo:i] for the left side and all v &gt; x for v in a[i:hi]
// for the right side.
d3.bisect =
d3.bisectRight = function(a, x, lo, hi) {
  if (arguments.length &lt; 3) lo = 0;
  if (arguments.length &lt; 4) hi = a.length;
  while (lo &lt; hi) {
    var mid = (lo + hi) &gt;&gt; 1;
    if (x &lt; a[mid]) hi = mid;
    else lo = mid + 1;
  }
  return lo;
};
d3.first = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i &lt; n) {
    if (f.call(array, a, b = array[i]) &gt; 0) {
      a = b;
    }
  }
  return a;
};
d3.last = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i &lt; n) {
    if (f.call(array, a, b = array[i]) &lt;= 0) {
      a = b;
    }
  }
  return a;
};
d3.nest = function() {
  var nest = {},
      keys = [],
      sortKeys = [],
      sortValues,
      rollup;

  function map(array, depth) {
    if (depth &gt;= keys.length) return rollup
        ? rollup.call(nest, array) : (sortValues
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        object,
        o = {};

    while (++i &lt; n) {
      if ((keyValue = key(object = array[i])) in o) {
        o[keyValue].push(object);
      } else {
        o[keyValue] = [object];
      }
    }

    for (keyValue in o) {
      o[keyValue] = map(o[keyValue], depth);
    }

    return o;
  }

  function entries(map, depth) {
    if (depth &gt;= keys.length) return map;

    var a = [],
        sortKey = sortKeys[depth++],
        key;

    for (key in map) {
      a.push({key: key, values: entries(map[key], depth)});
    }

    if (sortKey) a.sort(function(a, b) {
      return sortKey(a.key, b.key);
    });

    return a;
  }

  nest.map = function(array) {
    return map(array, 0);
  };

  nest.entries = function(array) {
    return entries(map(array, 0), 0);
  };

  nest.key = function(d) {
    keys.push(d);
    return nest;
  };

  // Specifies the order for the most-recently specified key.
  // Note: only applies to entries. Map keys are unordered!
  nest.sortKeys = function(order) {
    sortKeys[keys.length - 1] = order;
    return nest;
  };

  // Specifies the order for leaf values.
  // Applies to both maps and entries array.
  nest.sortValues = function(order) {
    sortValues = order;
    return nest;
  };

  nest.rollup = function(f) {
    rollup = f;
    return nest;
  };

  return nest;
};
d3.keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};
d3.values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};
d3.entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};
d3.permute = function(array, indexes) {
  var permutes = [],
      i = -1,
      n = indexes.length;
  while (++i &lt; n) permutes[i] = array[indexes[i]];
  return permutes;
};
d3.merge = function(arrays) {
  return Array.prototype.concat.apply([], arrays);
};
d3.split = function(array, f) {
  var arrays = [],
      values = [],
      value,
      i = -1,
      n = array.length;
  if (arguments.length &lt; 2) f = d3_splitter;
  while (++i &lt; n) {
    if (f.call(values, value = array[i], i)) {
      values = [];
    } else {
      if (!values.length) arrays.push(values);
      values.push(value);
    }
  }
  return arrays;
};

function d3_splitter(d) {
  return d == null;
}
function d3_collapse(s) {
  return s.replace(/(^\s+)|(\s+$)/g, &quot;&quot;).replace(/\s+/g, &quot; &quot;);
}
/**
 * @param {number} start
 * @param {number=} stop
 * @param {number=} step
 */
d3.range = function(start, stop, step) {
  if (arguments.length &lt; 3) {
    step = 1;
    if (arguments.length &lt; 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step == Infinity) throw new Error(&quot;infinite range&quot;);
  var range = [],
       i = -1,
       j;
  if (step &lt; 0) while ((j = start + step * ++i) &gt; stop) range.push(j);
  else while ((j = start + step * ++i) &lt; stop) range.push(j);
  return range;
};
d3.requote = function(s) {
  return s.replace(d3_requote_re, &quot;\\$&amp;&quot;);
};

var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
d3.round = function(x, n) {
  return n
      ? Math.round(x * (n = Math.pow(10, n))) / n
      : Math.round(x);
};
d3.xhr = function(url, mime, callback) {
  var req = new XMLHttpRequest;
  if (arguments.length &lt; 3) callback = mime, mime = null;
  else if (mime &amp;&amp; req.overrideMimeType) req.overrideMimeType(mime);
  req.open(&quot;GET&quot;, url, true);
  if (mime) req.setRequestHeader(&quot;Accept&quot;, mime);
  req.onreadystatechange = function() {
    if (req.readyState === 4) callback(req.status &lt; 300 ? req : null);
  };
  req.send(null);
};
d3.text = function(url, mime, callback) {
  function ready(req) {
    callback(req &amp;&amp; req.responseText);
  }
  if (arguments.length &lt; 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
d3.json = function(url, callback) {
  d3.text(url, &quot;application/json&quot;, function(text) {
    callback(text ? JSON.parse(text) : null);
  });
};
d3.html = function(url, callback) {
  d3.text(url, &quot;text/html&quot;, function(text) {
    if (text != null) { // Treat empty string as valid HTML.
      var range = document.createRange();
      range.selectNode(document.body);
      text = range.createContextualFragment(text);
    }
    callback(text);
  });
};
d3.xml = function(url, mime, callback) {
  function ready(req) {
    callback(req &amp;&amp; req.responseXML);
  }
  if (arguments.length &lt; 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
var d3_nsPrefix = {
  svg: &quot;http://www.w3.org/2000/svg&quot;,
  xhtml: &quot;http://www.w3.org/1999/xhtml&quot;,
  xlink: &quot;http://www.w3.org/1999/xlink&quot;,
  xml: &quot;http://www.w3.org/XML/1998/namespace&quot;,
  xmlns: &quot;http://www.w3.org/2000/xmlns/&quot;
};

d3.ns = {
  prefix: d3_nsPrefix,
  qualify: function(name) {
    var i = name.indexOf(&quot;:&quot;);
    return i &lt; 0 ? (name in d3_nsPrefix
      ? {space: d3_nsPrefix[name], local: name} : name)
      : {space: d3_nsPrefix[name.substring(0, i)], local: name.substring(i + 1)};
  }
};
d3.dispatch = function() {
  var dispatch = new d3_dispatch(),
      i = -1,
      n = arguments.length;
  while (++i &lt; n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
  return dispatch;
};

function d3_dispatch() {}

d3_dispatch.prototype.on = function(type, listener) {
  var i = type.indexOf(&quot;.&quot;),
      name = &quot;&quot;;

  // Extract optional namespace, e.g., &quot;click.foo&quot;
  if (i &gt; 0) {
    name = type.substring(i + 1);
    type = type.substring(0, i);
  }

  return arguments.length &lt; 2
      ? this[type].on(name)
      : this[type].on(name, listener);
};

function d3_dispatch_event(dispatch) {
  var listeners = [],
      listenerByName = {};

  function event() {
    var z = listeners, // defensive reference
        i = -1,
        n = z.length,
        l;
    while (++i &lt; n) if (l = z[i].on) l.apply(this, arguments);
    return dispatch;
  }

  event.on = function(name, listener) {
    var l, i;

    // return the current listener, if any
    if (arguments.length &lt; 2) return (l = listenerByName[name]) &amp;&amp; l.on;

    // remove the old listener, if any (with copy-on-write)
    if (l = listenerByName[name]) {
      l.on = null;
      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
      delete listenerByName[name];
    }

    // add the new listener, if any
    if (listener) {
      listeners.push(listenerByName[name] = {on: listener});
    }

    return dispatch;
  };

  return event;
}
// TODO align
d3.format = function(specifier) {
  var match = d3_format_re.exec(specifier),
      fill = match[1] || &quot; &quot;,
      sign = match[3] || &quot;&quot;,
      zfill = match[5],
      width = +match[6],
      comma = match[7],
      precision = match[8],
      type = match[9],
      scale = 1,
      suffix = &quot;&quot;,
      integer = false;

  if (precision) precision = +precision.substring(1);

  if (zfill) {
    fill = &quot;0&quot;; // TODO align = &quot;=&quot;;
    if (comma) width -= Math.floor((width - 1) / 4);
  }

  switch (type) {
    case &quot;n&quot;: comma = true; type = &quot;g&quot;; break;
    case &quot;%&quot;: scale = 100; suffix = &quot;%&quot;; type = &quot;f&quot;; break;
    case &quot;p&quot;: scale = 100; suffix = &quot;%&quot;; type = &quot;r&quot;; break;
    case &quot;d&quot;: integer = true; precision = 0; break;
    case &quot;s&quot;: scale = -1; type = &quot;r&quot;; break;
  }

  // If no precision is specified for r, fallback to general notation.
  if (type == &quot;r&quot; &amp;&amp; !precision) type = &quot;g&quot;;

  type = d3_format_types[type] || d3_format_typeDefault;

  return function(value) {

    // Return the empty string for floats formatted as ints.
    if (integer &amp;&amp; (value % 1)) return &quot;&quot;;

    // Convert negative to positive, and record the sign prefix.
    var negative = (value &lt; 0) &amp;&amp; (value = -value) ? &quot;\u2212&quot; : sign;

    // Apply the scale, computing it from the value&#x27;s exponent for si format.
    if (scale &lt; 0) {
      var prefix = d3.formatPrefix(value, precision);
      value *= prefix.scale;
      suffix = prefix.symbol;
    } else {
      value *= scale;
    }

    // Convert to the desired precision.
    value = type(value, precision);

    // If the fill character is 0, the sign and group is applied after the fill.
    if (zfill) {
      var length = value.length + negative.length;
      if (length &lt; width) value = new Array(width - length + 1).join(fill) + value;
      if (comma) value = d3_format_group(value);
      value = negative + value;
    }

    // Otherwise (e.g., space-filling), the sign and group is applied before.
    else {
      if (comma) value = d3_format_group(value);
      value = negative + value;
      var length = value.length;
      if (length &lt; width) value = new Array(width - length + 1).join(fill) + value;
    }

    return value + suffix;
  };
};

// [[fill]align][sign][#][0][width][,][.precision][type]
var d3_format_re = /(?:([^{])?([&lt;&gt;=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;

var d3_format_types = {
  g: function(x, p) { return x.toPrecision(p); },
  e: function(x, p) { return x.toExponential(p); },
  f: function(x, p) { return x.toFixed(p); },
  r: function(x, p) { return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p))); }
};

function d3_format_precision(x, p) {
  return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);
}

function d3_format_typeDefault(x) {
  return x + &quot;&quot;;
}

// Apply comma grouping for thousands.
function d3_format_group(value) {
  var i = value.lastIndexOf(&quot;.&quot;),
      f = i &gt;= 0 ? value.substring(i) : (i = value.length, &quot;&quot;),
      t = [];
  while (i &gt; 0) t.push(value.substring(i -= 3, i + 3));
  return t.reverse().join(&quot;,&quot;) + f;
}
var d3_formatPrefixes = [&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;μ&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;].map(d3_formatPrefix);

d3.formatPrefix = function(value, precision) {
  var i = 0;
  if (value) {
    if (value &lt; 0) value *= -1;
    if (precision) value = d3.round(value, d3_format_precision(value, precision));
    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
    i = Math.max(-24, Math.min(24, Math.floor((i &lt;= 0 ? i + 1 : i - 1) / 3) * 3));
  }
  return d3_formatPrefixes[8 + i / 3];
};

function d3_formatPrefix(d, i) {
  return {
    scale: Math.pow(10, (8 - i) * 3),
    symbol: d
  };
}

/*
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var d3_ease_quad = d3_ease_poly(2),
    d3_ease_cubic = d3_ease_poly(3);

var d3_ease = {
  linear: function() { return d3_ease_linear; },
  poly: d3_ease_poly,
  quad: function() { return d3_ease_quad; },
  cubic: function() { return d3_ease_cubic; },
  sin: function() { return d3_ease_sin; },
  exp: function() { return d3_ease_exp; },
  circle: function() { return d3_ease_circle; },
  elastic: d3_ease_elastic,
  back: d3_ease_back,
  bounce: function() { return d3_ease_bounce; }
};

var d3_ease_mode = {
  &quot;in&quot;: function(f) { return f; },
  &quot;out&quot;: d3_ease_reverse,
  &quot;in-out&quot;: d3_ease_reflect,
  &quot;out-in&quot;: function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }
};

d3.ease = function(name) {
  var i = name.indexOf(&quot;-&quot;),
      t = i &gt;= 0 ? name.substring(0, i) : name,
      m = i &gt;= 0 ? name.substring(i + 1) : &quot;in&quot;;
  return d3_ease_clamp(d3_ease_mode[m](d3_ease[t].apply(null, Array.prototype.slice.call(arguments, 1))));
};

function d3_ease_clamp(f) {
  return function(t) {
    return t &lt;= 0 ? 0 : t &gt;= 1 ? 1 : f(t);
  };
}

function d3_ease_reverse(f) {
  return function(t) {
    return 1 - f(1 - t);
  };
}

function d3_ease_reflect(f) {
  return function(t) {
    return .5 * (t &lt; .5 ? f(2 * t) : (2 - f(2 - 2 * t)));
  };
}

function d3_ease_linear(t) {
  return t;
}

function d3_ease_poly(e) {
  return function(t) {
    return Math.pow(t, e);
  }
}

function d3_ease_sin(t) {
  return 1 - Math.cos(t * Math.PI / 2);
}

function d3_ease_exp(t) {
  return Math.pow(2, 10 * (t - 1));
}

function d3_ease_circle(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function d3_ease_elastic(a, p) {
  var s;
  if (arguments.length &lt; 2) p = 0.45;
  if (arguments.length &lt; 1) { a = 1; s = p / 4; }
  else s = p / (2 * Math.PI) * Math.asin(1 / a);
  return function(t) {
    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);
  };
}

function d3_ease_back(s) {
  if (!s) s = 1.70158;
  return function(t) {
    return t * t * ((s + 1) * t - s);
  };
}

function d3_ease_bounce(t) {
  return t &lt; 1 / 2.75 ? 7.5625 * t * t
      : t &lt; 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75
      : t &lt; 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375
      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
}
d3.event = null;

function d3_eventCancel() {
  d3.event.stopPropagation();
  d3.event.preventDefault();
}
d3.interpolate = function(a, b) {
  var i = d3.interpolators.length, f;
  while (--i &gt;= 0 &amp;&amp; !(f = d3.interpolators[i](a, b)));
  return f;
};

d3.interpolateNumber = function(a, b) {
  b -= a;
  return function(t) { return a + b * t; };
};

d3.interpolateRound = function(a, b) {
  b -= a;
  return function(t) { return Math.round(a + b * t); };
};

d3.interpolateString = function(a, b) {
  var m, // current match
      i, // current index
      j, // current index (for coallescing)
      s0 = 0, // start index of current string prefix
      s1 = 0, // end index of current string prefix
      s = [], // string constants and placeholders
      q = [], // number interpolators
      n, // q.length
      o;

  // Reset our regular expression!
  d3_interpolate_number.lastIndex = 0;

  // Find all numbers in b.
  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
    if (m.index) s.push(b.substring(s0, s1 = m.index));
    q.push({i: s.length, x: m[0]});
    s.push(null);
    s0 = d3_interpolate_number.lastIndex;
  }
  if (s0 &lt; b.length) s.push(b.substring(s0));

  // Find all numbers in a.
  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) &amp;&amp; i &lt; n; ++i) {
    o = q[i];
    if (o.x == m[0]) { // The numbers match, so coallesce.
      if (o.i) {
        if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i - 1] += o.x;
          s.splice(o.i, 1);
          for (j = i + 1; j &lt; n; ++j) q[j].i--;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i - 1] += o.x + s[o.i + 1];
          s.splice(o.i, 2);
          for (j = i + 1; j &lt; n; ++j) q[j].i -= 2;
        }
      } else {
          if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i] = o.x;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i] = o.x + s[o.i + 1];
          s.splice(o.i + 1, 1);
          for (j = i + 1; j &lt; n; ++j) q[j].i--;
        }
      }
      q.splice(i, 1);
      n--;
      i--;
    } else {
      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
    }
  }

  // Remove any numbers in b not found in a.
  while (i &lt; n) {
    o = q.pop();
    if (s[o.i + 1] == null) { // This match is followed by another number.
      s[o.i] = o.x;
    } else { // This match is followed by a string, so coallesce twice.
      s[o.i] = o.x + s[o.i + 1];
      s.splice(o.i + 1, 1);
    }
    n--;
  }

  // Special optimization for only a single match.
  if (s.length === 1) {
    return s[0] == null ? q[0].x : function() { return b; };
  }

  // Otherwise, interpolate each of the numbers and rejoin the string.
  return function(t) {
    for (i = 0; i &lt; n; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join(&quot;&quot;);
  };
};

d3.interpolateTransform = function(a, b) {
  var s = [], // string constants and placeholders
      q = [], // number interpolators
      n,
      A = d3.transform(a),
      B = d3.transform(b),
      ta = A.translate,
      tb = B.translate,
      ra = A.rotate,
      rb = B.rotate,
      wa = A.skew,
      wb = B.skew,
      ka = A.scale,
      kb = B.scale;

  if (ta[0] != tb[0] || ta[1] != tb[1]) {
    s.push(&quot;translate(&quot;, null, &quot;,&quot;, null, &quot;)&quot;);
    q.push({i: 1, x: d3.interpolateNumber(ta[0], tb[0])}, {i: 3, x: d3.interpolateNumber(ta[1], tb[1])});
  } else if (tb[0] || tb[1]) {
    s.push(&quot;translate(&quot; + tb + &quot;)&quot;);
  } else {
    s.push(&quot;&quot;);
  }

  if (ra != rb) {
    q.push({i: s.push(s.pop() + &quot;rotate(&quot;, null, &quot;)&quot;) - 2, x: d3.interpolateNumber(ra, rb)});
  } else if (rb) {
    s.push(s.pop() + &quot;rotate(&quot; + rb + &quot;)&quot;);
  }

  if (wa != wb) {
    q.push({i: s.push(s.pop() + &quot;skewX(&quot;, null, &quot;)&quot;) - 2, x: d3.interpolateNumber(wa, wb)});
  } else if (wb) {
    s.push(s.pop() + &quot;skewX(&quot; + wb + &quot;)&quot;);
  }

  if (ka[0] != kb[0] || ka[1] != kb[1]) {
    n = s.push(s.pop() + &quot;scale(&quot;, null, &quot;,&quot;, null, &quot;)&quot;);
    q.push({i: n - 4, x: d3.interpolateNumber(ka[0], kb[0])}, {i: n - 2, x: d3.interpolateNumber(ka[1], kb[1])});
  } else if (kb[0] != 1 || kb[1] != 1) {
    s.push(s.pop() + &quot;scale(&quot; + kb + &quot;)&quot;);
  }

  n = q.length;
  return function(t) {
    var i = -1, o;
    while (++i &lt; n) s[(o = q[i]).i] = o.x(t);
    return s.join(&quot;&quot;);
  };
};

d3.interpolateRgb = function(a, b) {
  a = d3.rgb(a);
  b = d3.rgb(b);
  var ar = a.r,
      ag = a.g,
      ab = a.b,
      br = b.r - ar,
      bg = b.g - ag,
      bb = b.b - ab;
  return function(t) {
    return &quot;#&quot;
        + d3_rgb_hex(Math.round(ar + br * t))
        + d3_rgb_hex(Math.round(ag + bg * t))
        + d3_rgb_hex(Math.round(ab + bb * t));
  };
};

// interpolates HSL space, but outputs RGB string (for compatibility)
d3.interpolateHsl = function(a, b) {
  a = d3.hsl(a);
  b = d3.hsl(b);
  var h0 = a.h,
      s0 = a.s,
      l0 = a.l,
      h1 = b.h - h0,
      s1 = b.s - s0,
      l1 = b.l - l0;
  return function(t) {
    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();
  };
};

d3.interpolateArray = function(a, b) {
  var x = [],
      c = [],
      na = a.length,
      nb = b.length,
      n0 = Math.min(a.length, b.length),
      i;
  for (i = 0; i &lt; n0; ++i) x.push(d3.interpolate(a[i], b[i]));
  for (; i &lt; na; ++i) c[i] = a[i];
  for (; i &lt; nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i &lt; n0; ++i) c[i] = x[i](t);
    return c;
  };
};

d3.interpolateObject = function(a, b) {
  var i = {},
      c = {},
      k;
  for (k in a) {
    if (k in b) {
      i[k] = d3_interpolateByName(k)(a[k], b[k]);
    } else {
      c[k] = a[k];
    }
  }
  for (k in b) {
    if (!(k in a)) {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var d3_interpolate_number = /[-+]?(?:\d*\.?\d+)(?:[eE][-+]?\d+)?/g;

function d3_interpolateByName(n) {
  return n == &quot;transform&quot;
      ? d3.interpolateTransform
      : d3.interpolate;
}

d3.interpolators = [
  d3.interpolateObject,
  function(a, b) { return (b instanceof Array) &amp;&amp; d3.interpolateArray(a, b); },
  function(a, b) { return (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) &amp;&amp; d3.interpolateString(a + &quot;&quot;, b + &quot;&quot;); },
  function(a, b) { return (typeof b === &quot;string&quot; ? b in d3_rgb_names || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) &amp;&amp; d3.interpolateRgb(a, b); },
  function(a, b) { return !isNaN(a = +a) &amp;&amp; !isNaN(b = +b) &amp;&amp; d3.interpolateNumber(a, b); }
];
function d3_uninterpolateNumber(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return (x - a) * b; };
}

function d3_uninterpolateClamp(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };
}
d3.rgb = function(r, g, b) {
  return arguments.length === 1
      ? (r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b)
      : d3_rgb_parse(&quot;&quot; + r, d3_rgb, d3_hsl_rgb))
      : d3_rgb(~~r, ~~g, ~~b);
};

function d3_rgb(r, g, b) {
  return new d3_Rgb(r, g, b);
}

function d3_Rgb(r, g, b) {
  this.r = r;
  this.g = g;
  this.b = b;
}

d3_Rgb.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  var r = this.r,
      g = this.g,
      b = this.b,
      i = 30;
  if (!r &amp;&amp; !g &amp;&amp; !b) return d3_rgb(i, i, i);
  if (r &amp;&amp; r &lt; i) r = i;
  if (g &amp;&amp; g &lt; i) g = i;
  if (b &amp;&amp; b &lt; i) b = i;
  return d3_rgb(
      Math.min(255, Math.floor(r / k)),
      Math.min(255, Math.floor(g / k)),
      Math.min(255, Math.floor(b / k)));
};

d3_Rgb.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_rgb(
      Math.floor(k * this.r),
      Math.floor(k * this.g),
      Math.floor(k * this.b));
};

d3_Rgb.prototype.hsl = function() {
  return d3_rgb_hsl(this.r, this.g, this.b);
};

d3_Rgb.prototype.toString = function() {
  return &quot;#&quot; + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
};

function d3_rgb_hex(v) {
  return v &lt; 0x10
      ? &quot;0&quot; + Math.max(0, v).toString(16)
      : Math.min(255, v).toString(16);
}

function d3_rgb_parse(format, rgb, hsl) {
  var r = 0, // red channel; int in [0, 255]
      g = 0, // green channel; int in [0, 255]
      b = 0, // blue channel; int in [0, 255]
      m1, // CSS color specification match
      m2, // CSS color specification type (e.g., rgb)
      name;

  /* Handle hsl, rgb. */
  m1 = /([a-z]+)\((.*)\)/i.exec(format);
  if (m1) {
    m2 = m1[2].split(&quot;,&quot;);
    switch (m1[1]) {
      case &quot;hsl&quot;: {
        return hsl(
          parseFloat(m2[0]), // degrees
          parseFloat(m2[1]) / 100, // percentage
          parseFloat(m2[2]) / 100 // percentage
        );
      }
      case &quot;rgb&quot;: {
        return rgb(
          d3_rgb_parseNumber(m2[0]),
          d3_rgb_parseNumber(m2[1]),
          d3_rgb_parseNumber(m2[2])
        );
      }
    }
  }

  /* Named colors. */
  if (name = d3_rgb_names[format]) return rgb(name.r, name.g, name.b);

  /* Hexadecimal colors: #rgb and #rrggbb. */
  if (format != null &amp;&amp; format.charAt(0) === &quot;#&quot;) {
    if (format.length === 4) {
      r = format.charAt(1); r += r;
      g = format.charAt(2); g += g;
      b = format.charAt(3); b += b;
    } else if (format.length === 7) {
      r = format.substring(1, 3);
      g = format.substring(3, 5);
      b = format.substring(5, 7);
    }
    r = parseInt(r, 16);
    g = parseInt(g, 16);
    b = parseInt(b, 16);
  }

  return rgb(r, g, b);
}

function d3_rgb_hsl(r, g, b) {
  var min = Math.min(r /= 255, g /= 255, b /= 255),
      max = Math.max(r, g, b),
      d = max - min,
      h,
      s,
      l = (max + min) / 2;
  if (d) {
    s = l &lt; .5 ? d / (max + min) : d / (2 - max - min);
    if (r == max) h = (g - b) / d + (g &lt; b ? 6 : 0);
    else if (g == max) h = (b - r) / d + 2;
    else h = (r - g) / d + 4;
    h *= 60;
  } else {
    s = h = 0;
  }
  return d3_hsl(h, s, l);
}

function d3_rgb_parseNumber(c) { // either integer or percentage
  var f = parseFloat(c);
  return c.charAt(c.length - 1) === &quot;%&quot; ? Math.round(f * 2.55) : f;
}

var d3_rgb_names = {
  aliceblue: &quot;#f0f8ff&quot;,
  antiquewhite: &quot;#faebd7&quot;,
  aqua: &quot;#00ffff&quot;,
  aquamarine: &quot;#7fffd4&quot;,
  azure: &quot;#f0ffff&quot;,
  beige: &quot;#f5f5dc&quot;,
  bisque: &quot;#ffe4c4&quot;,
  black: &quot;#000000&quot;,
  blanchedalmond: &quot;#ffebcd&quot;,
  blue: &quot;#0000ff&quot;,
  blueviolet: &quot;#8a2be2&quot;,
  brown: &quot;#a52a2a&quot;,
  burlywood: &quot;#deb887&quot;,
  cadetblue: &quot;#5f9ea0&quot;,
  chartreuse: &quot;#7fff00&quot;,
  chocolate: &quot;#d2691e&quot;,
  coral: &quot;#ff7f50&quot;,
  cornflowerblue: &quot;#6495ed&quot;,
  cornsilk: &quot;#fff8dc&quot;,
  crimson: &quot;#dc143c&quot;,
  cyan: &quot;#00ffff&quot;,
  darkblue: &quot;#00008b&quot;,
  darkcyan: &quot;#008b8b&quot;,
  darkgoldenrod: &quot;#b8860b&quot;,
  darkgray: &quot;#a9a9a9&quot;,
  darkgreen: &quot;#006400&quot;,
  darkgrey: &quot;#a9a9a9&quot;,
  darkkhaki: &quot;#bdb76b&quot;,
  darkmagenta: &quot;#8b008b&quot;,
  darkolivegreen: &quot;#556b2f&quot;,
  darkorange: &quot;#ff8c00&quot;,
  darkorchid: &quot;#9932cc&quot;,
  darkred: &quot;#8b0000&quot;,
  darksalmon: &quot;#e9967a&quot;,
  darkseagreen: &quot;#8fbc8f&quot;,
  darkslateblue: &quot;#483d8b&quot;,
  darkslategray: &quot;#2f4f4f&quot;,
  darkslategrey: &quot;#2f4f4f&quot;,
  darkturquoise: &quot;#00ced1&quot;,
  darkviolet: &quot;#9400d3&quot;,
  deeppink: &quot;#ff1493&quot;,
  deepskyblue: &quot;#00bfff&quot;,
  dimgray: &quot;#696969&quot;,
  dimgrey: &quot;#696969&quot;,
  dodgerblue: &quot;#1e90ff&quot;,
  firebrick: &quot;#b22222&quot;,
  floralwhite: &quot;#fffaf0&quot;,
  forestgreen: &quot;#228b22&quot;,
  fuchsia: &quot;#ff00ff&quot;,
  gainsboro: &quot;#dcdcdc&quot;,
  ghostwhite: &quot;#f8f8ff&quot;,
  gold: &quot;#ffd700&quot;,
  goldenrod: &quot;#daa520&quot;,
  gray: &quot;#808080&quot;,
  green: &quot;#008000&quot;,
  greenyellow: &quot;#adff2f&quot;,
  grey: &quot;#808080&quot;,
  honeydew: &quot;#f0fff0&quot;,
  hotpink: &quot;#ff69b4&quot;,
  indianred: &quot;#cd5c5c&quot;,
  indigo: &quot;#4b0082&quot;,
  ivory: &quot;#fffff0&quot;,
  khaki: &quot;#f0e68c&quot;,
  lavender: &quot;#e6e6fa&quot;,
  lavenderblush: &quot;#fff0f5&quot;,
  lawngreen: &quot;#7cfc00&quot;,
  lemonchiffon: &quot;#fffacd&quot;,
  lightblue: &quot;#add8e6&quot;,
  lightcoral: &quot;#f08080&quot;,
  lightcyan: &quot;#e0ffff&quot;,
  lightgoldenrodyellow: &quot;#fafad2&quot;,
  lightgray: &quot;#d3d3d3&quot;,
  lightgreen: &quot;#90ee90&quot;,
  lightgrey: &quot;#d3d3d3&quot;,
  lightpink: &quot;#ffb6c1&quot;,
  lightsalmon: &quot;#ffa07a&quot;,
  lightseagreen: &quot;#20b2aa&quot;,
  lightskyblue: &quot;#87cefa&quot;,
  lightslategray: &quot;#778899&quot;,
  lightslategrey: &quot;#778899&quot;,
  lightsteelblue: &quot;#b0c4de&quot;,
  lightyellow: &quot;#ffffe0&quot;,
  lime: &quot;#00ff00&quot;,
  limegreen: &quot;#32cd32&quot;,
  linen: &quot;#faf0e6&quot;,
  magenta: &quot;#ff00ff&quot;,
  maroon: &quot;#800000&quot;,
  mediumaquamarine: &quot;#66cdaa&quot;,
  mediumblue: &quot;#0000cd&quot;,
  mediumorchid: &quot;#ba55d3&quot;,
  mediumpurple: &quot;#9370db&quot;,
  mediumseagreen: &quot;#3cb371&quot;,
  mediumslateblue: &quot;#7b68ee&quot;,
  mediumspringgreen: &quot;#00fa9a&quot;,
  mediumturquoise: &quot;#48d1cc&quot;,
  mediumvioletred: &quot;#c71585&quot;,
  midnightblue: &quot;#191970&quot;,
  mintcream: &quot;#f5fffa&quot;,
  mistyrose: &quot;#ffe4e1&quot;,
  moccasin: &quot;#ffe4b5&quot;,
  navajowhite: &quot;#ffdead&quot;,
  navy: &quot;#000080&quot;,
  oldlace: &quot;#fdf5e6&quot;,
  olive: &quot;#808000&quot;,
  olivedrab: &quot;#6b8e23&quot;,
  orange: &quot;#ffa500&quot;,
  orangered: &quot;#ff4500&quot;,
  orchid: &quot;#da70d6&quot;,
  palegoldenrod: &quot;#eee8aa&quot;,
  palegreen: &quot;#98fb98&quot;,
  paleturquoise: &quot;#afeeee&quot;,
  palevioletred: &quot;#db7093&quot;,
  papayawhip: &quot;#ffefd5&quot;,
  peachpuff: &quot;#ffdab9&quot;,
  peru: &quot;#cd853f&quot;,
  pink: &quot;#ffc0cb&quot;,
  plum: &quot;#dda0dd&quot;,
  powderblue: &quot;#b0e0e6&quot;,
  purple: &quot;#800080&quot;,
  red: &quot;#ff0000&quot;,
  rosybrown: &quot;#bc8f8f&quot;,
  royalblue: &quot;#4169e1&quot;,
  saddlebrown: &quot;#8b4513&quot;,
  salmon: &quot;#fa8072&quot;,
  sandybrown: &quot;#f4a460&quot;,
  seagreen: &quot;#2e8b57&quot;,
  seashell: &quot;#fff5ee&quot;,
  sienna: &quot;#a0522d&quot;,
  silver: &quot;#c0c0c0&quot;,
  skyblue: &quot;#87ceeb&quot;,
  slateblue: &quot;#6a5acd&quot;,
  slategray: &quot;#708090&quot;,
  slategrey: &quot;#708090&quot;,
  snow: &quot;#fffafa&quot;,
  springgreen: &quot;#00ff7f&quot;,
  steelblue: &quot;#4682b4&quot;,
  tan: &quot;#d2b48c&quot;,
  teal: &quot;#008080&quot;,
  thistle: &quot;#d8bfd8&quot;,
  tomato: &quot;#ff6347&quot;,
  turquoise: &quot;#40e0d0&quot;,
  violet: &quot;#ee82ee&quot;,
  wheat: &quot;#f5deb3&quot;,
  white: &quot;#ffffff&quot;,
  whitesmoke: &quot;#f5f5f5&quot;,
  yellow: &quot;#ffff00&quot;,
  yellowgreen: &quot;#9acd32&quot;
};

for (var d3_rgb_name in d3_rgb_names) {
  d3_rgb_names[d3_rgb_name] = d3_rgb_parse(
      d3_rgb_names[d3_rgb_name],
      d3_rgb,
      d3_hsl_rgb);
}
d3.hsl = function(h, s, l) {
  return arguments.length === 1
      ? (h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l)
      : d3_rgb_parse(&quot;&quot; + h, d3_rgb_hsl, d3_hsl))
      : d3_hsl(+h, +s, +l);
};

function d3_hsl(h, s, l) {
  return new d3_Hsl(h, s, l);
}

function d3_Hsl(h, s, l) {
  this.h = h;
  this.s = s;
  this.l = l;
}

d3_Hsl.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, this.l / k);
};

d3_Hsl.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, k * this.l);
};

d3_Hsl.prototype.rgb = function() {
  return d3_hsl_rgb(this.h, this.s, this.l);
};

d3_Hsl.prototype.toString = function() {
  return this.rgb().toString();
};

function d3_hsl_rgb(h, s, l) {
  var m1,
      m2;

  /* Some simple corrections for h, s and l. */
  h = h % 360; if (h &lt; 0) h += 360;
  s = s &lt; 0 ? 0 : s &gt; 1 ? 1 : s;
  l = l &lt; 0 ? 0 : l &gt; 1 ? 1 : l;

  /* From FvD 13.37, CSS Color Module Level 3 */
  m2 = l &lt;= .5 ? l * (1 + s) : l + s - l * s;
  m1 = 2 * l - m2;

  function v(h) {
    if (h &gt; 360) h -= 360;
    else if (h &lt; 0) h += 360;
    if (h &lt; 60) return m1 + (m2 - m1) * h / 60;
    if (h &lt; 180) return m2;
    if (h &lt; 240) return m1 + (m2 - m1) * (240 - h) / 60;
    return m1;
  }

  function vv(h) {
    return Math.round(v(h) * 255);
  }

  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
}
function d3_selection(groups) {
  d3_arraySubclass(groups, d3_selectionPrototype);
  return groups;
}

var d3_select = function(s, n) { return n.querySelector(s); },
    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },
    d3_selectRoot = document.documentElement,
    d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector,
    d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); };

// Prefer Sizzle, if available.
if (typeof Sizzle === &quot;function&quot;) {
  d3_select = function(s, n) { return Sizzle(s, n)[0]; };
  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };
  d3_selectMatches = Sizzle.matchesSelector;
}

var d3_selectionPrototype = [];

d3.selection = function() {
  return d3_selectionRoot;
};

d3.selection.prototype = d3_selectionPrototype;
d3_selectionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      group,
      node;

  if (typeof selector !== &quot;function&quot;) selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j &lt; m;) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = -1, n = group.length; ++i &lt; n;) {
      if (node = group[i]) {
        subgroup.push(subnode = selector.call(node, node.__data__, i));
        if (subnode &amp;&amp; &quot;__data__&quot; in node) subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selector(selector) {
  return function() {
    return d3_select(selector, this);
  };
}
d3_selectionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      node;

  if (typeof selector !== &quot;function&quot;) selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j &lt; m;) {
    for (var group = this[j], i = -1, n = group.length; ++i &lt; n;) {
      if (node = group[i]) {
        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
        subgroup.parentNode = node;
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selectorAll(selector) {
  return function() {
    return d3_selectAll(selector, this);
  };
}
d3_selectionPrototype.attr = function(name, value) {
  name = d3.ns.qualify(name);

  // If no value is specified, return the first value.
  if (arguments.length &lt; 2) {
    var node = this.node();
    return name.local
        ? node.getAttributeNS(name.space, name.local)
        : node.getAttribute(name);
  }

  function attrNull() {
    this.removeAttribute(name);
  }

  function attrNullNS() {
    this.removeAttributeNS(name.space, name.local);
  }

  function attrConstant() {
    this.setAttribute(name, value);
  }

  function attrConstantNS() {
    this.setAttributeNS(name.space, name.local, value);
  }

  function attrFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttribute(name);
    else this.setAttribute(name, x);
  }

  function attrFunctionNS() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttributeNS(name.space, name.local);
    else this.setAttributeNS(name.space, name.local, x);
  }

  return this.each(value == null
      ? (name.local ? attrNullNS : attrNull) : (typeof value === &quot;function&quot;
      ? (name.local ? attrFunctionNS : attrFunction)
      : (name.local ? attrConstantNS : attrConstant)));
};
d3_selectionPrototype.classed = function(name, value) {
  var names = name.split(d3_selection_classedWhitespace),
      n = names.length,
      i = -1;
  if (arguments.length &gt; 1) {
    while (++i &lt; n) d3_selection_classed.call(this, names[i], value);
    return this;
  } else {
    while (++i &lt; n) if (!d3_selection_classed.call(this, names[i])) return false;
    return true;
  }
};

var d3_selection_classedWhitespace = /\s+/g;

function d3_selection_classed(name, value) {
  var re = new RegExp(&quot;(^|\\s+)&quot; + d3.requote(name) + &quot;(\\s+|$)&quot;, &quot;g&quot;);

  // If no value is specified, return the first value.
  if (arguments.length &lt; 2) {
    var node = this.node();
    if (c = node.classList) return c.contains(name);
    var c = node.className;
    re.lastIndex = 0;
    return re.test(c.baseVal != null ? c.baseVal : c);
  }

  function classedAdd() {
    if (c = this.classList) return c.add(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    re.lastIndex = 0;
    if (!re.test(cv)) {
      cv = d3_collapse(cv + &quot; &quot; + name);
      if (cb) c.baseVal = cv;
      else this.className = cv;
    }
  }

  function classedRemove() {
    if (c = this.classList) return c.remove(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    cv = d3_collapse(cv.replace(re, &quot; &quot;));
    if (cb) c.baseVal = cv;
    else this.className = cv;
  }

  function classedFunction() {
    (value.apply(this, arguments)
        ? classedAdd
        : classedRemove).call(this);
  }

  return this.each(typeof value === &quot;function&quot;
      ? classedFunction : value
      ? classedAdd
      : classedRemove);
}
d3_selectionPrototype.style = function(name, value, priority) {
  if (arguments.length &lt; 3) priority = &quot;&quot;;

  // If no value is specified, return the first value.
  if (arguments.length &lt; 2) return window
      .getComputedStyle(this.node(), null)
      .getPropertyValue(name);

  function styleNull() {
    this.style.removeProperty(name);
  }

  function styleConstant() {
    this.style.setProperty(name, value, priority);
  }

  function styleFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.style.removeProperty(name);
    else this.style.setProperty(name, x, priority);
  }

  return this.each(value == null
      ? styleNull : (typeof value === &quot;function&quot;
      ? styleFunction : styleConstant));
};
d3_selectionPrototype.property = function(name, value) {

  // If no value is specified, return the first value.
  if (arguments.length &lt; 2) return this.node()[name];

  function propertyNull() {
    delete this[name];
  }

  function propertyConstant() {
    this[name] = value;
  }

  function propertyFunction() {
    var x = value.apply(this, arguments);
    if (x == null) delete this[name];
    else this[name] = x;
  }

  return this.each(value == null
      ? propertyNull : (typeof value === &quot;function&quot;
      ? propertyFunction : propertyConstant));
};
d3_selectionPrototype.text = function(value) {
  return arguments.length &lt; 1
      ? this.node().textContent : this.each(typeof value === &quot;function&quot;
      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? &quot;&quot; : v; } : value == null
      ? function() { this.textContent = &quot;&quot;; }
      : function() { this.textContent = value; });
};
d3_selectionPrototype.html = function(value) {
  return arguments.length &lt; 1
      ? this.node().innerHTML : this.each(typeof value === &quot;function&quot;
      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? &quot;&quot; : v; } : value == null
      ? function() { this.innerHTML = &quot;&quot;; }
      : function() { this.innerHTML = value; });
};
// TODO append(node)?
// TODO append(function)?
d3_selectionPrototype.append = function(name) {
  name = d3.ns.qualify(name);

  function append() {
    return this.appendChild(document.createElementNS(this.namespaceURI, name));
  }

  function appendNS() {
    return this.appendChild(document.createElementNS(name.space, name.local));
  }

  return this.select(name.local ? appendNS : append);
};
// TODO insert(node, function)?
// TODO insert(function, string)?
// TODO insert(function, function)?
d3_selectionPrototype.insert = function(name, before) {
  name = d3.ns.qualify(name);

  function insert() {
    return this.insertBefore(
        document.createElementNS(this.namespaceURI, name),
        d3_select(before, this));
  }

  function insertNS() {
    return this.insertBefore(
        document.createElementNS(name.space, name.local),
        d3_select(before, this));
  }

  return this.select(name.local ? insertNS : insert);
};
// TODO remove(selector)?
// TODO remove(node)?
// TODO remove(function)?
d3_selectionPrototype.remove = function() {
  return this.each(function() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  });
};
// TODO data(null) for clearing data?
d3_selectionPrototype.data = function(data, join) {
  var enter = [],
      update = [],
      exit = [];

  function bind(group, groupData) {
    var i,
        n = group.length,
        m = groupData.length,
        n0 = Math.min(n, m),
        n1 = Math.max(n, m),
        updateNodes = [],
        enterNodes = [],
        exitNodes = [],
        node,
        nodeData;

    if (join) {
      var nodeByKey = {},
          keys = [],
          key,
          j = groupData.length;

      for (i = -1; ++i &lt; n;) {
        key = join.call(node = group[i], node.__data__, i);
        if (key in nodeByKey) {
          exitNodes[j++] = node; // duplicate key
        } else {
          nodeByKey[key] = node;
        }
        keys.push(key);
      }

      for (i = -1; ++i &lt; m;) {
        node = nodeByKey[key = join.call(groupData, nodeData = groupData[i], i)];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
        delete nodeByKey[key];
      }

      for (i = -1; ++i &lt; n;) {
        if (keys[i] in nodeByKey) {
          exitNodes[i] = group[i];
        }
      }
    } else {
      for (i = -1; ++i &lt; n0;) {
        node = group[i];
        nodeData = groupData[i];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
      }
      for (; i &lt; m; ++i) {
        enterNodes[i] = d3_selection_dataNode(groupData[i]);
        updateNodes[i] = exitNodes[i] = null;
      }
      for (; i &lt; n1; ++i) {
        exitNodes[i] = group[i];
        enterNodes[i] = updateNodes[i] = null;
      }
    }

    enterNodes.update
        = updateNodes;

    enterNodes.parentNode
        = updateNodes.parentNode
        = exitNodes.parentNode
        = group.parentNode;

    enter.push(enterNodes);
    update.push(updateNodes);
    exit.push(exitNodes);
  }

  var i = -1,
      n = this.length,
      group;
  if (typeof data === &quot;function&quot;) {
    while (++i &lt; n) {
      bind(group = this[i], data.call(group, group.parentNode.__data__, i));
    }
  } else {
    while (++i &lt; n) {
      bind(group = this[i], data);
    }
  }

  var selection = d3_selection(update);
  selection.enter = function() { return d3_selection_enter(enter); };
  selection.exit = function() { return d3_selection(exit); };
  return selection;
};

function d3_selection_dataNode(data) {
  return {__data__: data};
}
d3_selectionPrototype.filter = function(filter) {
  var subgroups = [],
      subgroup,
      group,
      node;

  if (typeof filter !== &quot;function&quot;) filter = d3_selection_filter(filter);

  for (var j = 0, m = this.length; j &lt; m; j++) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = 0, n = group.length; i &lt; n; i++) {
      if ((node = group[i]) &amp;&amp; filter.call(node, node.__data__, i)) {
        subgroup.push(node);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_filter(selector) {
  return function() {
    return d3_selectMatches(this, selector);
  };
}
d3_selectionPrototype.map = function(map) {
  return this.each(function() {
    this.__data__ = map.apply(this, arguments);
  });
};
d3_selectionPrototype.order = function() {
  for (var j = -1, m = this.length; ++j &lt; m;) {
    for (var group = this[j], i = group.length - 1, next = group[i], node; --i &gt;= 0;) {
      if (node = group[i]) {
        if (next &amp;&amp; next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
};
d3_selectionPrototype.sort = function(comparator) {
  comparator = d3_selection_sortComparator.apply(this, arguments);
  for (var j = -1, m = this.length; ++j &lt; m;) this[j].sort(comparator);
  return this.order();
};

function d3_selection_sortComparator(comparator) {
  if (!arguments.length) comparator = d3.ascending;
  return function(a, b) {
    return comparator(a &amp;&amp; a.__data__, b &amp;&amp; b.__data__);
  };
}
// type can be namespaced, e.g., &quot;click.foo&quot;
// listener can be null for removal
d3_selectionPrototype.on = function(type, listener, capture) {
  if (arguments.length &lt; 3) capture = false;

  // parse the type specifier
  var name = &quot;__on&quot; + type, i = type.indexOf(&quot;.&quot;);
  if (i &gt; 0) type = type.substring(0, i);

  // if called with only one argument, return the current listener
  if (arguments.length &lt; 2) return (i = this.node()[name]) &amp;&amp; i._;

  // remove the old event listener, and add the new event listener
  return this.each(function(d, i) {
    var node = this;

    if (node[name]) node.removeEventListener(type, node[name], capture);
    if (listener) node.addEventListener(type, node[name] = l, capture);

    // wrapped event listener that preserves i
    function l(e) {
      var o = d3.event; // Events can be reentrant (e.g., focus).
      d3.event = e;
      try {
        listener.call(node, node.__data__, i);
      } finally {
        d3.event = o;
      }
    }

    // stash the unwrapped listener for retrieval
    l._ = listener;
  });
};
d3_selectionPrototype.each = function(callback) {
  for (var j = -1, m = this.length; ++j &lt; m;) {
    for (var group = this[j], i = -1, n = group.length; ++i &lt; n;) {
      var node = group[i];
      if (node) callback.call(node, node.__data__, i, j);
    }
  }
  return this;
};
//
// Note: assigning to the arguments array simultaneously changes the value of
// the corresponding argument!
//
// TODO The &#x60;this&#x60; argument probably shouldn&#x27;t be the first argument to the
// callback, anyway, since it&#x27;s redundant. However, that will require a major
// version bump due to backwards compatibility, so I&#x27;m not changing it right
// away.
//
d3_selectionPrototype.call = function(callback) {
  callback.apply(this, (arguments[0] = this, arguments));
  return this;
};
d3_selectionPrototype.empty = function() {
  return !this.node();
};
d3_selectionPrototype.node = function(callback) {
  for (var j = 0, m = this.length; j &lt; m; j++) {
    for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
};
d3_selectionPrototype.transition = function() {
  var subgroups = [],
      subgroup,
      node;

  for (var j = -1, m = this.length; ++j &lt; m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i &lt; n;) {
      subgroup.push((node = group[i]) ? {node: node, delay: 0, duration: 250} : null);
    }
  }

  return d3_transition(subgroups, d3_transitionInheritId || ++d3_transitionId, Date.now());
};
var d3_selectionRoot = d3_selection([[document]]);

d3_selectionRoot[0].parentNode = d3_selectRoot;

// TODO fast singleton implementation!
// TODO select(function)
d3.select = function(selector) {
  return typeof selector === &quot;string&quot;
      ? d3_selectionRoot.select(selector)
      : d3_selection([[selector]]); // assume node
};

// TODO selectAll(function)
d3.selectAll = function(selector) {
  return typeof selector === &quot;string&quot;
      ? d3_selectionRoot.selectAll(selector)
      : d3_selection([d3_array(selector)]); // assume node[]
};
function d3_selection_enter(selection) {
  d3_arraySubclass(selection, d3_selection_enterPrototype);
  return selection;
}

var d3_selection_enterPrototype = [];

d3_selection_enterPrototype.append = d3_selectionPrototype.append;
d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
d3_selection_enterPrototype.node = d3_selectionPrototype.node;
d3_selection_enterPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      upgroup,
      group,
      node;

  for (var j = -1, m = this.length; ++j &lt; m;) {
    upgroup = (group = this[j]).update;
    subgroups.push(subgroup = []);
    subgroup.parentNode = group.parentNode;
    for (var i = -1, n = group.length; ++i &lt; n;) {
      if (node = group[i]) {
        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
        subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};
function d3_transition(groups, id, time) {
  d3_arraySubclass(groups, d3_transitionPrototype);

  var tweens = {},
      event = d3.dispatch(&quot;start&quot;, &quot;end&quot;),
      ease = d3_transitionEase;

  groups.id = id;

  groups.time = time;

  groups.tween = function(name, tween) {
    if (arguments.length &lt; 2) return tweens[name];
    if (tween == null) delete tweens[name];
    else tweens[name] = tween;
    return groups;
  };

  groups.ease = function(value) {
    if (!arguments.length) return ease;
    ease = typeof value === &quot;function&quot; ? value : d3.ease.apply(d3, arguments);
    return groups;
  };

  groups.each = function(type, listener) {
    if (arguments.length &lt; 2) return d3_transition_each.call(groups, type);
    event.on(type, listener);
    return groups;
  };

  d3.timer(function(elapsed) {
    groups.each(function(d, i, j) {
      var tweened = [],
          node = this,
          delay = groups[j][i].delay,
          duration = groups[j][i].duration,
          lock = node.__transition__ || (node.__transition__ = {active: 0, count: 0});

      ++lock.count;

      delay &lt;= elapsed ? start(elapsed) : d3.timer(start, delay, time);

      function start(elapsed) {
        if (lock.active &gt; id) return stop();
        lock.active = id;

        for (var tween in tweens) {
          if (tween = tweens[tween].call(node, d, i)) {
            tweened.push(tween);
          }
        }

        event.start.call(node, d, i);
        if (!tick(elapsed)) d3.timer(tick, 0, time);
        return 1;
      }

      function tick(elapsed) {
        if (lock.active !== id) return stop();

        var t = (elapsed - delay) / duration,
            e = ease(t),
            n = tweened.length;

        while (n &gt; 0) {
          tweened[--n].call(node, e);
        }

        if (t &gt;= 1) {
          stop();
          d3_transitionInheritId = id;
          event.end.call(node, d, i);
          d3_transitionInheritId = 0;
          return 1;
        }
      }

      function stop() {
        if (!--lock.count) delete node.__transition__;
        return 1;
      }
    });
    return 1;
  }, 0, time);

  return groups;
}

var d3_transitionRemove = {};

function d3_transitionNull(d, i, a) {
  return a != &quot;&quot; &amp;&amp; d3_transitionRemove;
}

function d3_transitionTween(name, b) {
  var interpolate = d3_interpolateByName(name);

  function transitionFunction(d, i, a) {
    var v = b.call(this, d, i);
    return v == null
        ? a != &quot;&quot; &amp;&amp; d3_transitionRemove
        : a != v &amp;&amp; interpolate(a, v);
  }

  function transitionString(d, i, a) {
    return a != b &amp;&amp; interpolate(a, b);
  }

  return typeof b === &quot;function&quot; ? transitionFunction
      : b == null ? d3_transitionNull
      : (b += &quot;&quot;, transitionString);
}

var d3_transitionPrototype = [],
    d3_transitionId = 0,
    d3_transitionInheritId = 0,
    d3_transitionEase = d3.ease(&quot;cubic-in-out&quot;);

d3_transitionPrototype.call = d3_selectionPrototype.call;

d3.transition = function() {
  return d3_selectionRoot.transition();
};

d3.transition.prototype = d3_transitionPrototype;
d3_transitionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      node;

  if (typeof selector !== &quot;function&quot;) selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j &lt; m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i &lt; n;) {
      if ((node = group[i]) &amp;&amp; (subnode = selector.call(node.node, node.node.__data__, i))) {
        if (&quot;__data__&quot; in node.node) subnode.__data__ = node.node.__data__;
        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      subnodes,
      node;

  if (typeof selector !== &quot;function&quot;) selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j &lt; m;) {
    for (var group = this[j], i = -1, n = group.length; ++i &lt; n;) {
      if (node = group[i]) {
        subnodes = selector.call(node.node, node.node.__data__, i);
        subgroups.push(subgroup = []);
        for (var k = -1, o = subnodes.length; ++k &lt; o;) {
          subgroup.push({node: subnodes[k], delay: node.delay, duration: node.duration});
        }
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.attr = function(name, value) {
  return this.attrTween(name, d3_transitionTween(name, value));
};

d3_transitionPrototype.attrTween = function(nameNS, tween) {
  var name = d3.ns.qualify(nameNS);

  function attrTween(d, i) {
    var f = tween.call(this, d, i, this.getAttribute(name));
    return f === d3_transitionRemove
        ? (this.removeAttribute(name), null)
        : f &amp;&amp; function(t) { this.setAttribute(name, f(t)); };
  }

  function attrTweenNS(d, i) {
    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
    return f === d3_transitionRemove
        ? (this.removeAttributeNS(name.space, name.local), null)
        : f &amp;&amp; function(t) { this.setAttributeNS(name.space, name.local, f(t)); };
  }

  return this.tween(&quot;attr.&quot; + nameNS, name.local ? attrTweenNS : attrTween);
};
d3_transitionPrototype.style = function(name, value, priority) {
  if (arguments.length &lt; 3) priority = &quot;&quot;;
  return this.styleTween(name, d3_transitionTween(name, value), priority);
};

d3_transitionPrototype.styleTween = function(name, tween, priority) {
  if (arguments.length &lt; 3) priority = &quot;&quot;;
  return this.tween(&quot;style.&quot; + name, function(d, i) {
    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));
    return f === d3_transitionRemove
        ? (this.style.removeProperty(name), null)
        : f &amp;&amp; function(t) { this.style.setProperty(name, f(t), priority); };
  });
};
d3_transitionPrototype.text = function(value) {
  return this.tween(&quot;text&quot;, function(d, i) {
    this.textContent = typeof value === &quot;function&quot;
        ? value.call(this, d, i)
        : value;
  });
};
d3_transitionPrototype.remove = function() {
  return this.each(&quot;end.transition&quot;, function() {
    var p;
    if (!this.__transition__ &amp;&amp; (p = this.parentNode)) p.removeChild(this);
  });
};
d3_transitionPrototype.delay = function(value) {
  var groups = this;
  return groups.each(typeof value === &quot;function&quot;
      ? function(d, i, j) { groups[j][i].delay = +value.apply(this, arguments); }
      : (value = +value, function(d, i, j) { groups[j][i].delay = value; }));
};
d3_transitionPrototype.duration = function(value) {
  var groups = this;
  return groups.each(typeof value === &quot;function&quot;
      ? function(d, i, j) { groups[j][i].duration = +value.apply(this, arguments); }
      : (value = +value, function(d, i, j) { groups[j][i].duration = value; }));
};
function d3_transition_each(callback) {
  for (var j = 0, m = this.length; j &lt; m; j++) {
    for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) {
      var node = group[i];
      if (node) callback.call(node = node.node, node.__data__, i, j);
    }
  }
  return this;
}
d3_transitionPrototype.transition = function() {
  return this.select(d3_this);
};
var d3_timer_queue = null,
    d3_timer_interval, // is an interval (or frame) active?
    d3_timer_timeout; // is a timeout active?

// The timer will continue to fire until callback returns true.
d3.timer = function(callback, delay, then) {
  var found = false,
      t0,
      t1 = d3_timer_queue;

  if (arguments.length &lt; 3) {
    if (arguments.length &lt; 2) delay = 0;
    else if (!isFinite(delay)) return;
    then = Date.now();
  }

  // See if the callback&#x27;s already in the queue.
  while (t1) {
    if (t1.callback === callback) {
      t1.then = then;
      t1.delay = delay;
      found = true;
      break;
    }
    t0 = t1;
    t1 = t1.next;
  }

  // Otherwise, add the callback to the queue.
  if (!found) d3_timer_queue = {
    callback: callback,
    then: then,
    delay: delay,
    next: d3_timer_queue
  };

  // Start animatin&#x27;!
  if (!d3_timer_interval) {
    d3_timer_timeout = clearTimeout(d3_timer_timeout);
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

function d3_timer_step() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (elapsed &gt;= t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  var delay = d3_timer_flush() - now;
  if (delay &gt; 24) {
    if (isFinite(delay)) {
      clearTimeout(d3_timer_timeout);
      d3_timer_timeout = setTimeout(d3_timer_step, delay);
    }
    d3_timer_interval = 0;
  } else {
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

d3.timer.flush = function() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (!t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  d3_timer_flush();
};

// Flush after callbacks, to avoid concurrent queue modification.
function d3_timer_flush() {
  var t0 = null,
      t1 = d3_timer_queue,
      then = Infinity;
  while (t1) {
    if (t1.flush) {
      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
    } else {
      then = Math.min(then, t1.then + t1.delay);
      t1 = (t0 = t1).next;
    }
  }
  return then;
}

var d3_timer_frame = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.oRequestAnimationFrame
    || window.msRequestAnimationFrame
    || function(callback) { setTimeout(callback, 17); };
d3.transform = function(string) {
  var g = document.createElementNS(d3.ns.prefix.svg, &quot;g&quot;),
      identity = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};
  return (d3.transform = function(string) {
    g.setAttribute(&quot;transform&quot;, string);
    var t = g.transform.baseVal.consolidate();
    return new d3_transform(t ? t.matrix : identity);
  })(string);
};

// Compute x-scale and normalize the first row.
// Compute shear and make second row orthogonal to first.
// Compute y-scale and normalize the second row.
// Finally, compute the rotation.
function d3_transform(m) {
  var r0 = [m.a, m.b],
      r1 = [m.c, m.d],
      kx = d3_transformNormalize(r0),
      kz = d3_transformDot(r0, r1),
      ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
  if (r0[0] * r1[1] &lt; r1[0] * r0[1]) {
    r0[0] *= -1;
    r0[1] *= -1;
    kx *= -1;
    kz *= -1;
  }
  this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_transformDegrees;
  this.translate = [m.e, m.f];
  this.scale = [kx, ky];
  this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;
};

d3_transform.prototype.toString = function() {
  return &quot;translate(&quot; + this.translate
      + &quot;)rotate(&quot; + this.rotate
      + &quot;)skewX(&quot; + this.skew
      + &quot;)scale(&quot; + this.scale
      + &quot;)&quot;;
};

function d3_transformDot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

function d3_transformNormalize(a) {
  var k = Math.sqrt(d3_transformDot(a, a));
  if (k) {
    a[0] /= k;
    a[1] /= k;
  }
  return k;
}

function d3_transformCombine(a, b, k) {
  a[0] += k * b[0];
  a[1] += k * b[1];
  return a;
}

var d3_transformDegrees = 180 / Math.PI;
function d3_noop() {}
d3.scale = {};

function d3_scaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start &lt; stop ? [start, stop] : [stop, start];
}

function d3_scaleRange(scale) {
  return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
}
function d3_scale_nice(domain, nice) {
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      dx;

  if (x1 &lt; x0) {
    dx = i0; i0 = i1; i1 = dx;
    dx = x0; x0 = x1; x1 = dx;
  }

  if (dx = x1 - x0) {
    nice = nice(dx);
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
  }

  return domain;
}

function d3_scale_niceDefault() {
  return Math;
}
d3.scale.linear = function() {
  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);
};

function d3_scale_linear(domain, range, interpolate, clamp) {
  var output,
      input;

  function rescale() {
    var linear = domain.length == 2 ? d3_scale_bilinear : d3_scale_polylinear,
        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
    output = linear(domain, range, uninterpolate, interpolate);
    input = linear(range, domain, uninterpolate, d3.interpolate);
    return scale;
  }

  function scale(x) {
    return output(x);
  }

  // Note: requires range is coercible to number!
  scale.invert = function(y) {
    return input(y);
  };

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.map(Number);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.rangeRound = function(x) {
    return scale.range(x).interpolate(d3.interpolateRound);
  };

  scale.clamp = function(x) {
    if (!arguments.length) return clamp;
    clamp = x;
    return rescale();
  };

  scale.interpolate = function(x) {
    if (!arguments.length) return interpolate;
    interpolate = x;
    return rescale();
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(domain, m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(domain, m);
  };

  scale.nice = function() {
    d3_scale_nice(domain, d3_scale_linearNice);
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_linear(domain, range, interpolate, clamp);
  };

  return rescale();
};

function d3_scale_linearRebind(scale, linear) {
  return d3.rebind(scale, linear, &quot;range&quot;, &quot;rangeRound&quot;, &quot;interpolate&quot;, &quot;clamp&quot;);
}

function d3_scale_linearNice(dx) {
  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
  return {
    floor: function(x) { return Math.floor(x / dx) * dx; },
    ceil: function(x) { return Math.ceil(x / dx) * dx; }
  };
}

function d3_scale_linearTickRange(domain, m) {
  var extent = d3_scaleExtent(domain),
      span = extent[1] - extent[0],
      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
      err = m / span * step;

  // Filter ticks to get closer to the desired count.
  if (err &lt;= .15) step *= 10;
  else if (err &lt;= .35) step *= 5;
  else if (err &lt;= .75) step *= 2;

  // Round start and stop values to step interval.
  extent[0] = Math.ceil(extent[0] / step) * step;
  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive
  extent[2] = step;
  return extent;
}

function d3_scale_linearTicks(domain, m) {
  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
}

function d3_scale_linearTickFormat(domain, m) {
  return d3.format(&quot;,.&quot; + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + &quot;f&quot;);
}
function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
  var u = uninterpolate(domain[0], domain[1]),
      i = interpolate(range[0], range[1]);
  return function(x) {
    return i(u(x));
  };
}
function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
  var u = [],
      i = [],
      j = 0,
      k = domain.length - 1;

  // Handle descending domains.
  if (domain[k] &lt; domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++j &lt;= k) {
    u.push(uninterpolate(domain[j - 1], domain[j]));
    i.push(interpolate(range[j - 1], range[j]));
  }

  return function(x) {
    var j = d3.bisect(domain, x, 1, k) - 1;
    return i[j](u[j](x));
  };
}
d3.scale.log = function() {
  return d3_scale_log(d3.scale.linear(), d3_scale_logp);
};

function d3_scale_log(linear, log) {
  var pow = log.pow;

  function scale(x) {
    return linear(log(x));
  }

  scale.invert = function(x) {
    return pow(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(pow);
    log = x[0] &lt; 0 ? d3_scale_logn : d3_scale_logp;
    pow = log.pow;
    linear.domain(x.map(log));
    return scale;
  };

  scale.nice = function() {
    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
    return scale;
  };

  scale.ticks = function() {
    var extent = d3_scaleExtent(linear.domain()),
        ticks = [];
    if (extent.every(isFinite)) {
      var i = Math.floor(extent[0]),
          j = Math.ceil(extent[1]),
          u = pow(extent[0]),
          v = pow(extent[1]);
      if (log === d3_scale_logn) {
        ticks.push(pow(i));
        for (; i++ &lt; j;) for (var k = 9; k &gt; 0; k--) ticks.push(pow(i) * k);
      } else {
        for (; i &lt; j; i++) for (var k = 1; k &lt; 10; k++) ticks.push(pow(i) * k);
        ticks.push(pow(i));
      }
      for (i = 0; ticks[i] &lt; u; i++) {} // strip small values
      for (j = ticks.length; ticks[j - 1] &gt; v; j--) {} // strip big values
      ticks = ticks.slice(i, j);
    }
    return ticks;
  };

  scale.tickFormat = function(n, format) {
    if (arguments.length &lt; 2) format = d3_scale_logFormat;
    if (arguments.length &lt; 1) return format;
    var k = n / scale.ticks().length,
        f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil),
        e;
    return function(d) {
      return d / pow(f(log(d) + e)) &lt; k ? format(d) : &quot;&quot;;
    };
  };

  scale.copy = function() {
    return d3_scale_log(linear.copy(), log);
  };

  return d3_scale_linearRebind(scale, linear);
};

var d3_scale_logFormat = d3.format(&quot;.0e&quot;);

function d3_scale_logp(x) {
  return Math.log(x &lt; 0 ? 0 : x) / Math.LN10;
}

function d3_scale_logn(x) {
  return -Math.log(x &gt; 0 ? 0 : -x) / Math.LN10;
}

d3_scale_logp.pow = function(x) {
  return Math.pow(10, x);
};

d3_scale_logn.pow = function(x) {
  return -Math.pow(10, -x);
};
d3.scale.pow = function() {
  return d3_scale_pow(d3.scale.linear(), 1);
};

function d3_scale_pow(linear, exponent) {
  var powp = d3_scale_powPow(exponent),
      powb = d3_scale_powPow(1 / exponent);

  function scale(x) {
    return linear(powp(x));
  }

  scale.invert = function(x) {
    return powb(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(powb);
    linear.domain(x.map(powp));
    return scale;
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(scale.domain(), m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(scale.domain(), m);
  };

  scale.nice = function() {
    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
  };

  scale.exponent = function(x) {
    if (!arguments.length) return exponent;
    var domain = scale.domain();
    powp = d3_scale_powPow(exponent = x);
    powb = d3_scale_powPow(1 / exponent);
    return scale.domain(domain);
  };

  scale.copy = function() {
    return d3_scale_pow(linear.copy(), exponent);
  };

  return d3_scale_linearRebind(scale, linear);
};

function d3_scale_powPow(e) {
  return function(x) {
    return x &lt; 0 ? -Math.pow(-x, e) : Math.pow(x, e);
  };
}
d3.scale.sqrt = function() {
  return d3.scale.pow().exponent(.5);
};
d3.scale.ordinal = function() {
  return d3_scale_ordinal([], {t: &quot;range&quot;, x: []});
};

function d3_scale_ordinal(domain, ranger) {
  var index,
      range,
      rangeBand;

  function scale(x) {
    return range[((index[x] || (index[x] = domain.push(x))) - 1) % range.length];
  }

  function steps(start, step) {
    return d3.range(domain.length).map(function(i) { return start + step * i; });
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = [];
    index = {};
    var i = -1, n = x.length, xi;
    while (++i &lt; n) if (!index[xi = x[i]]) index[xi] = domain.push(xi);
    return scale[ranger.t](ranger.x, ranger.p);
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    rangeBand = 0;
    ranger = {t: &quot;range&quot;, x: x};
    return scale;
  };

  scale.rangePoints = function(x, padding) {
    if (arguments.length &lt; 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = (stop - start) / (domain.length - 1 + padding);
    range = steps(domain.length &lt; 2 ? (start + stop) / 2 : start + step * padding / 2, step);
    rangeBand = 0;
    ranger = {t: &quot;rangePoints&quot;, x: x, p: padding};
    return scale;
  };

  scale.rangeBands = function(x, padding) {
    if (arguments.length &lt; 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = (stop - start) / (domain.length + padding);
    range = steps(start + step * padding, step);
    rangeBand = step * (1 - padding);
    ranger = {t: &quot;rangeBands&quot;, x: x, p: padding};
    return scale;
  };

  scale.rangeRoundBands = function(x, padding) {
    if (arguments.length &lt; 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = Math.floor((stop - start) / (domain.length + padding));
    range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
    rangeBand = Math.round(step * (1 - padding));
    ranger = {t: &quot;rangeRoundBands&quot;, x: x, p: padding};
    return scale;
  };

  scale.rangeBand = function() {
    return rangeBand;
  };

  scale.rangeExtent = function() {
    return ranger.t === &quot;range&quot; ? d3_scaleExtent(ranger.x) : ranger.x;
  };

  scale.copy = function() {
    return d3_scale_ordinal(domain, ranger);
  };

  return scale.domain(domain);
};
/*
 * This product includes color specifications and designs developed by Cynthia
 * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.
 */

d3.scale.category10 = function() {
  return d3.scale.ordinal().range(d3_category10);
};

d3.scale.category20 = function() {
  return d3.scale.ordinal().range(d3_category20);
};

d3.scale.category20b = function() {
  return d3.scale.ordinal().range(d3_category20b);
};

d3.scale.category20c = function() {
  return d3.scale.ordinal().range(d3_category20c);
};

var d3_category10 = [
  &quot;#1f77b4&quot;, &quot;#ff7f0e&quot;, &quot;#2ca02c&quot;, &quot;#d62728&quot;, &quot;#9467bd&quot;,
  &quot;#8c564b&quot;, &quot;#e377c2&quot;, &quot;#7f7f7f&quot;, &quot;#bcbd22&quot;, &quot;#17becf&quot;
];

var d3_category20 = [
  &quot;#1f77b4&quot;, &quot;#aec7e8&quot;,
  &quot;#ff7f0e&quot;, &quot;#ffbb78&quot;,
  &quot;#2ca02c&quot;, &quot;#98df8a&quot;,
  &quot;#d62728&quot;, &quot;#ff9896&quot;,
  &quot;#9467bd&quot;, &quot;#c5b0d5&quot;,
  &quot;#8c564b&quot;, &quot;#c49c94&quot;,
  &quot;#e377c2&quot;, &quot;#f7b6d2&quot;,
  &quot;#7f7f7f&quot;, &quot;#c7c7c7&quot;,
  &quot;#bcbd22&quot;, &quot;#dbdb8d&quot;,
  &quot;#17becf&quot;, &quot;#9edae5&quot;
];

var d3_category20b = [
  &quot;#393b79&quot;, &quot;#5254a3&quot;, &quot;#6b6ecf&quot;, &quot;#9c9ede&quot;,
  &quot;#637939&quot;, &quot;#8ca252&quot;, &quot;#b5cf6b&quot;, &quot;#cedb9c&quot;,
  &quot;#8c6d31&quot;, &quot;#bd9e39&quot;, &quot;#e7ba52&quot;, &quot;#e7cb94&quot;,
  &quot;#843c39&quot;, &quot;#ad494a&quot;, &quot;#d6616b&quot;, &quot;#e7969c&quot;,
  &quot;#7b4173&quot;, &quot;#a55194&quot;, &quot;#ce6dbd&quot;, &quot;#de9ed6&quot;
];

var d3_category20c = [
  &quot;#3182bd&quot;, &quot;#6baed6&quot;, &quot;#9ecae1&quot;, &quot;#c6dbef&quot;,
  &quot;#e6550d&quot;, &quot;#fd8d3c&quot;, &quot;#fdae6b&quot;, &quot;#fdd0a2&quot;,
  &quot;#31a354&quot;, &quot;#74c476&quot;, &quot;#a1d99b&quot;, &quot;#c7e9c0&quot;,
  &quot;#756bb1&quot;, &quot;#9e9ac8&quot;, &quot;#bcbddc&quot;, &quot;#dadaeb&quot;,
  &quot;#636363&quot;, &quot;#969696&quot;, &quot;#bdbdbd&quot;, &quot;#d9d9d9&quot;
];
d3.scale.quantile = function() {
  return d3_scale_quantile([], []);
};

function d3_scale_quantile(domain, range) {
  var thresholds;

  function rescale() {
    var k = 0,
        n = domain.length,
        q = range.length;
    thresholds = [];
    while (++k &lt; q) thresholds[k - 1] = d3.quantile(domain, k / q);
    return scale;
  }

  function scale(x) {
    if (isNaN(x = +x)) return NaN;
    return range[d3.bisect(thresholds, x)];
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.quantiles = function() {
    return thresholds;
  };

  scale.copy = function() {
    return d3_scale_quantile(domain, range); // copy on write!
  };

  return rescale();
};
d3.scale.quantize = function() {
  return d3_scale_quantize(0, 1, [0, 1]);
};

function d3_scale_quantize(x0, x1, range) {
  var kx, i;

  function scale(x) {
    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
  }

  function rescale() {
    kx = range.length / (x1 - x0);
    i = range.length - 1;
    return scale;
  }

  scale.domain = function(x) {
    if (!arguments.length) return [x0, x1];
    x0 = +x[0];
    x1 = +x[x.length - 1];
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_quantize(x0, x1, range); // copy on write
  };

  return rescale();
};
d3.svg = {};
d3.svg.arc = function() {
  var innerRadius = d3_svg_arcInnerRadius,
      outerRadius = d3_svg_arcOuterRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  function arc() {
    var r0 = innerRadius.apply(this, arguments),
        r1 = outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,
        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,
        da = (a1 &lt; a0 &amp;&amp; (da = a0, a0 = a1, a1 = da), a1 - a0),
        df = da &lt; Math.PI ? &quot;0&quot; : &quot;1&quot;,
        c0 = Math.cos(a0),
        s0 = Math.sin(a0),
        c1 = Math.cos(a1),
        s1 = Math.sin(a1);
    return da &gt;= d3_svg_arcMax
      ? (r0
      ? &quot;M0,&quot; + r1
      + &quot;A&quot; + r1 + &quot;,&quot; + r1 + &quot; 0 1,1 0,&quot; + (-r1)
      + &quot;A&quot; + r1 + &quot;,&quot; + r1 + &quot; 0 1,1 0,&quot; + r1
      + &quot;M0,&quot; + r0
      + &quot;A&quot; + r0 + &quot;,&quot; + r0 + &quot; 0 1,0 0,&quot; + (-r0)
      + &quot;A&quot; + r0 + &quot;,&quot; + r0 + &quot; 0 1,0 0,&quot; + r0
      + &quot;Z&quot;
      : &quot;M0,&quot; + r1
      + &quot;A&quot; + r1 + &quot;,&quot; + r1 + &quot; 0 1,1 0,&quot; + (-r1)
      + &quot;A&quot; + r1 + &quot;,&quot; + r1 + &quot; 0 1,1 0,&quot; + r1
      + &quot;Z&quot;)
      : (r0
      ? &quot;M&quot; + r1 * c0 + &quot;,&quot; + r1 * s0
      + &quot;A&quot; + r1 + &quot;,&quot; + r1 + &quot; 0 &quot; + df + &quot;,1 &quot; + r1 * c1 + &quot;,&quot; + r1 * s1
      + &quot;L&quot; + r0 * c1 + &quot;,&quot; + r0 * s1
      + &quot;A&quot; + r0 + &quot;,&quot; + r0 + &quot; 0 &quot; + df + &quot;,0 &quot; + r0 * c0 + &quot;,&quot; + r0 * s0
      + &quot;Z&quot;
      : &quot;M&quot; + r1 * c0 + &quot;,&quot; + r1 * s0
      + &quot;A&quot; + r1 + &quot;,&quot; + r1 + &quot; 0 &quot; + df + &quot;,1 &quot; + r1 * c1 + &quot;,&quot; + r1 * s1
      + &quot;L0,0&quot;
      + &quot;Z&quot;);
  }

  arc.innerRadius = function(v) {
    if (!arguments.length) return innerRadius;
    innerRadius = d3.functor(v);
    return arc;
  };

  arc.outerRadius = function(v) {
    if (!arguments.length) return outerRadius;
    outerRadius = d3.functor(v);
    return arc;
  };

  arc.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3.functor(v);
    return arc;
  };

  arc.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3.functor(v);
    return arc;
  };

  arc.centroid = function() {
    var r = (innerRadius.apply(this, arguments)
        + outerRadius.apply(this, arguments)) / 2,
        a = (startAngle.apply(this, arguments)
        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  return arc;
};

var d3_svg_arcOffset = -Math.PI / 2,
    d3_svg_arcMax = 2 * Math.PI - 1e-6;

function d3_svg_arcInnerRadius(d) {
  return d.innerRadius;
}

function d3_svg_arcOuterRadius(d) {
  return d.outerRadius;
}

function d3_svg_arcStartAngle(d) {
  return d.startAngle;
}

function d3_svg_arcEndAngle(d) {
  return d.endAngle;
}
function d3_svg_line(projection) {
  var x = d3_svg_lineX,
      y = d3_svg_lineY,
      interpolate = &quot;linear&quot;,
      interpolator = d3_svg_lineInterpolators[interpolate],
      tension = .7;

  function line(d) {
    return d.length &lt; 1 ? null : &quot;M&quot; + interpolator(projection(d3_svg_linePoints(this, d, x, y)), tension);
  }

  line.x = function(v) {
    if (!arguments.length) return x;
    x = v;
    return line;
  };

  line.y = function(v) {
    if (!arguments.length) return y;
    y = v;
    return line;
  };

  line.interpolate = function(v) {
    if (!arguments.length) return interpolate;
    interpolator = d3_svg_lineInterpolators[interpolate = v];
    return line;
  };

  line.tension = function(v) {
    if (!arguments.length) return tension;
    tension = v;
    return line;
  };

  return line;
}

d3.svg.line = function() {
  return d3_svg_line(Object);
};

// Converts the specified array of data into an array of points
// (x-y tuples), by evaluating the specified &#x60;x&#x60; and &#x60;y&#x60; functions on each
// data point. The &#x60;this&#x60; context of the evaluated functions is the specified
// &quot;self&quot; object; each function is passed the current datum and index.
function d3_svg_linePoints(self, d, x, y) {
  var points = [],
      i = -1,
      n = d.length,
      fx = typeof x === &quot;function&quot;,
      fy = typeof y === &quot;function&quot;,
      value;
  if (fx &amp;&amp; fy) {
    while (++i &lt; n) points.push([
      x.call(self, value = d[i], i),
      y.call(self, value, i)
    ]);
  } else if (fx) {
    while (++i &lt; n) points.push([x.call(self, d[i], i), y]);
  } else if (fy) {
    while (++i &lt; n) points.push([x, y.call(self, d[i], i)]);
  } else {
    while (++i &lt; n) points.push([x, y]);
  }
  return points;
}

// The default &#x60;x&#x60; property, which references d[0].
function d3_svg_lineX(d) {
  return d[0];
}

// The default &#x60;y&#x60; property, which references d[1].
function d3_svg_lineY(d) {
  return d[1];
}

// The various interpolators supported by the &#x60;line&#x60; class.
var d3_svg_lineInterpolators = {
  &quot;linear&quot;: d3_svg_lineLinear,
  &quot;step-before&quot;: d3_svg_lineStepBefore,
  &quot;step-after&quot;: d3_svg_lineStepAfter,
  &quot;basis&quot;: d3_svg_lineBasis,
  &quot;basis-open&quot;: d3_svg_lineBasisOpen,
  &quot;basis-closed&quot;: d3_svg_lineBasisClosed,
  &quot;bundle&quot;: d3_svg_lineBundle,
  &quot;cardinal&quot;: d3_svg_lineCardinal,
  &quot;cardinal-open&quot;: d3_svg_lineCardinalOpen,
  &quot;cardinal-closed&quot;: d3_svg_lineCardinalClosed,
  &quot;monotone&quot;: d3_svg_lineMonotone
};

// Linear interpolation; generates &quot;L&quot; commands.
function d3_svg_lineLinear(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], &quot;,&quot;, p[1]];
  while (++i &lt; n) path.push(&quot;L&quot;, (p = points[i])[0], &quot;,&quot;, p[1]);
  return path.join(&quot;&quot;);
}

// Step interpolation; generates &quot;H&quot; and &quot;V&quot; commands.
function d3_svg_lineStepBefore(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], &quot;,&quot;, p[1]];
  while (++i &lt; n) path.push(&quot;V&quot;, (p = points[i])[1], &quot;H&quot;, p[0]);
  return path.join(&quot;&quot;);
}

// Step interpolation; generates &quot;H&quot; and &quot;V&quot; commands.
function d3_svg_lineStepAfter(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], &quot;,&quot;, p[1]];
  while (++i &lt; n) path.push(&quot;H&quot;, (p = points[i])[0], &quot;V&quot;, p[1]);
  return path.join(&quot;&quot;);
}

// Open cardinal spline interpolation; generates &quot;C&quot; commands.
function d3_svg_lineCardinalOpen(points, tension) {
  return points.length &lt; 4
      ? d3_svg_lineLinear(points)
      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),
        d3_svg_lineCardinalTangents(points, tension));
}

// Closed cardinal spline interpolation; generates &quot;C&quot; commands.
function d3_svg_lineCardinalClosed(points, tension) {
  return points.length &lt; 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),
        d3_svg_lineCardinalTangents([points[points.length - 2]]
        .concat(points, [points[1]]), tension));
}

// Cardinal spline interpolation; generates &quot;C&quot; commands.
function d3_svg_lineCardinal(points, tension, closed) {
  return points.length &lt; 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite(points,
        d3_svg_lineCardinalTangents(points, tension));
}

// Hermite spline construction; generates &quot;C&quot; commands.
function d3_svg_lineHermite(points, tangents) {
  if (tangents.length &lt; 1
      || (points.length != tangents.length
      &amp;&amp; points.length != tangents.length + 2)) {
    return d3_svg_lineLinear(points);
  }

  var quad = points.length != tangents.length,
      path = &quot;&quot;,
      p0 = points[0],
      p = points[1],
      t0 = tangents[0],
      t = t0,
      pi = 1;

  if (quad) {
    path += &quot;Q&quot; + (p[0] - t0[0] * 2 / 3) + &quot;,&quot; + (p[1] - t0[1] * 2 / 3)
        + &quot;,&quot; + p[0] + &quot;,&quot; + p[1];
    p0 = points[1];
    pi = 2;
  }

  if (tangents.length &gt; 1) {
    t = tangents[1];
    p = points[pi];
    pi++;
    path += &quot;C&quot; + (p0[0] + t0[0]) + &quot;,&quot; + (p0[1] + t0[1])
        + &quot;,&quot; + (p[0] - t[0]) + &quot;,&quot; + (p[1] - t[1])
        + &quot;,&quot; + p[0] + &quot;,&quot; + p[1];
    for (var i = 2; i &lt; tangents.length; i++, pi++) {
      p = points[pi];
      t = tangents[i];
      path += &quot;S&quot; + (p[0] - t[0]) + &quot;,&quot; + (p[1] - t[1])
          + &quot;,&quot; + p[0] + &quot;,&quot; + p[1];
    }
  }

  if (quad) {
    var lp = points[pi];
    path += &quot;Q&quot; + (p[0] + t[0] * 2 / 3) + &quot;,&quot; + (p[1] + t[1] * 2 / 3)
        + &quot;,&quot; + lp[0] + &quot;,&quot; + lp[1];
  }

  return path;
}

// Generates tangents for a cardinal spline.
function d3_svg_lineCardinalTangents(points, tension) {
  var tangents = [],
      a = (1 - tension) / 2,
      p0,
      p1 = points[0],
      p2 = points[1],
      i = 1,
      n = points.length;
  while (++i &lt; n) {
    p0 = p1;
    p1 = p2;
    p2 = points[i];
    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
  }
  return tangents;
}

// B-spline interpolation; generates &quot;C&quot; commands.
function d3_svg_lineBasis(points) {
  if (points.length &lt; 3) return d3_svg_lineLinear(points);
  var i = 1,
      n = points.length,
      pi = points[0],
      x0 = pi[0],
      y0 = pi[1],
      px = [x0, x0, x0, (pi = points[1])[0]],
      py = [y0, y0, y0, pi[1]],
      path = [x0, &quot;,&quot;, y0];
  d3_svg_lineBasisBezier(path, px, py);
  while (++i &lt; n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  i = -1;
  while (++i &lt; 2) {
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join(&quot;&quot;);
}

// Open B-spline interpolation; generates &quot;C&quot; commands.
function d3_svg_lineBasisOpen(points) {
  if (points.length &lt; 4) return d3_svg_lineLinear(points);
  var path = [],
      i = -1,
      n = points.length,
      pi,
      px = [0],
      py = [0];
  while (++i &lt; 3) {
    pi = points[i];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)
    + &quot;,&quot; + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
  --i; while (++i &lt; n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join(&quot;&quot;);
}

// Closed B-spline interpolation; generates &quot;C&quot; commands.
function d3_svg_lineBasisClosed(points) {
  var path,
      i = -1,
      n = points.length,
      m = n + 4,
      pi,
      px = [],
      py = [];
  while (++i &lt; 4) {
    pi = points[i % n];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path = [
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), &quot;,&quot;,
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
  ];
  --i; while (++i &lt; m) {
    pi = points[i % n];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join(&quot;&quot;);
}

function d3_svg_lineBundle(points, tension) {
  var n = points.length - 1,
      x0 = points[0][0],
      y0 = points[0][1],
      dx = points[n][0] - x0,
      dy = points[n][1] - y0,
      i = -1,
      p,
      t;
  while (++i &lt;= n) {
    p = points[i];
    t = i / n;
    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
  }
  return d3_svg_lineBasis(points);
}

// Returns the dot product of the given four-element vectors.
function d3_svg_lineDot4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

// Matrix to transform basis (b-spline) control points to bezier
// control points. Derived from FvD 11.2.8.
var d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],
    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],
    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];

// Pushes a &quot;C&quot; Bézier curve onto the specified path array, given the
// two specified four-element arrays which define the control points.
function d3_svg_lineBasisBezier(path, x, y) {
  path.push(
      &quot;C&quot;, d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),
      &quot;,&quot;, d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),
      &quot;,&quot;, d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),
      &quot;,&quot;, d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),
      &quot;,&quot;, d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),
      &quot;,&quot;, d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
}

// Computes the slope from points p0 to p1.
function d3_svg_lineSlope(p0, p1) {
  return (p1[1] - p0[1]) / (p1[0] - p0[0]);
}

// Compute three-point differences for the given points.
// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference
function d3_svg_lineFiniteDifferences(points) {
  var i = 0,
      j = points.length - 1,
      m = [],
      p0 = points[0],
      p1 = points[1],
      d = m[0] = d3_svg_lineSlope(p0, p1);
  while (++i &lt; j) {
    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));
  }
  m[i] = d;
  return m;
}

// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite
// interpolation. Returns an array of tangent vectors. For details, see
// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
function d3_svg_lineMonotoneTangents(points) {
  var tangents = [],
      d,
      a,
      b,
      s,
      m = d3_svg_lineFiniteDifferences(points),
      i = -1,
      j = points.length - 1;

  // The first two steps are done by computing finite-differences:
  // 1. Compute the slopes of the secant lines between successive points.
  // 2. Initialize the tangents at every point as the average of the secants.

  // Then, for each segment…
  while (++i &lt; j) {
    d = d3_svg_lineSlope(points[i], points[i + 1]);

    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set
    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to
    // preserve monotonicity. Ignore step 4 and 5 for those k.

    if (Math.abs(d) &lt; 1e-6) {
      m[i] = m[i + 1] = 0;
    } else {
      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.
      a = m[i] / d;
      b = m[i + 1] / d;

      // 5. Prevent overshoot and ensure monotonicity by restricting the
      // magnitude of vector &lt;ak, bk&gt; to a circle of radius 3.
      s = a * a + b * b;
      if (s &gt; 9) {
        s = d * 3 / Math.sqrt(s);
        m[i] = s * a;
        m[i + 1] = s * b;
      }
    }
  }

  // Compute the normalized tangent vector from the slopes. Note that if x is
  // not monotonic, it&#x27;s possible that the slope will be infinite, so we protect
  // against NaN by setting the coordinate to zero.
  i = -1; while (++i &lt;= j) {
    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0])
      / (6 * (1 + m[i] * m[i]));
    tangents.push([s || 0, m[i] * s || 0]);
  }

  return tangents;
}

function d3_svg_lineMonotone(points) {
  return points.length &lt; 3
      ? d3_svg_lineLinear(points)
      : points[0] +
        d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
}
d3.svg.line.radial = function() {
  var line = d3_svg_line(d3_svg_lineRadial);
  line.radius = line.x, delete line.x;
  line.angle = line.y, delete line.y;
  return line;
};

function d3_svg_lineRadial(points) {
  var point,
      i = -1,
      n = points.length,
      r,
      a;
  while (++i &lt; n) {
    point = points[i];
    r = point[0];
    a = point[1] + d3_svg_arcOffset;
    point[0] = r * Math.cos(a);
    point[1] = r * Math.sin(a);
  }
  return points;
}
function d3_svg_area(projection) {
  var x0 = d3_svg_lineX,
      x1 = d3_svg_lineX,
      y0 = 0,
      y1 = d3_svg_lineY,
      interpolate,
      i0,
      i1,
      tension = .7;

  function area(d) {
    if (d.length &lt; 1) return null;
    var points0 = d3_svg_linePoints(this, d, x0, y0),
        points1 = d3_svg_linePoints(this, d, x0 === x1 ? d3_svg_areaX(points0) : x1, y0 === y1 ? d3_svg_areaY(points0) : y1);
    return &quot;M&quot; + i0(projection(points1), tension)
         + &quot;L&quot; + i1(projection(points0.reverse()), tension)
         + &quot;Z&quot;;
  }

  area.x = function(x) {
    if (!arguments.length) return x1;
    x0 = x1 = x;
    return area;
  };

  area.x0 = function(x) {
    if (!arguments.length) return x0;
    x0 = x;
    return area;
  };

  area.x1 = function(x) {
    if (!arguments.length) return x1;
    x1 = x;
    return area;
  };

  area.y = function(y) {
    if (!arguments.length) return y1;
    y0 = y1 = y;
    return area;
  };

  area.y0 = function(y) {
    if (!arguments.length) return y0;
    y0 = y;
    return area;
  };

  area.y1 = function(y) {
    if (!arguments.length) return y1;
    y1 = y;
    return area;
  };

  area.interpolate = function(x) {
    if (!arguments.length) return interpolate;
    i0 = d3_svg_lineInterpolators[interpolate = x];
    i1 = i0.reverse || i0;
    return area;
  };

  area.tension = function(x) {
    if (!arguments.length) return tension;
    tension = x;
    return area;
  };

  return area.interpolate(&quot;linear&quot;);
}

d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;

d3.svg.area = function() {
  return d3_svg_area(Object);
};

function d3_svg_areaX(points) {
  return function(d, i) {
    return points[i][0];
  };
}

function d3_svg_areaY(points) {
  return function(d, i) {
    return points[i][1];
  };
}
d3.svg.area.radial = function() {
  var area = d3_svg_area(d3_svg_lineRadial);
  area.radius = area.x, delete area.x;
  area.innerRadius = area.x0, delete area.x0;
  area.outerRadius = area.x1, delete area.x1;
  area.angle = area.y, delete area.y;
  area.startAngle = area.y0, delete area.y0;
  area.endAngle = area.y1, delete area.y1;
  return area;
};
d3.svg.chord = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      radius = d3_svg_chordRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  // TODO Allow control point to be customized.

  function chord(d, i) {
    var s = subgroup(this, source, d, i),
        t = subgroup(this, target, d, i);
    return &quot;M&quot; + s.p0
      + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t)
      ? curve(s.r, s.p1, s.r, s.p0)
      : curve(s.r, s.p1, t.r, t.p0)
      + arc(t.r, t.p1, t.a1 - t.a0)
      + curve(t.r, t.p1, s.r, s.p0))
      + &quot;Z&quot;;
  }

  function subgroup(self, f, d, i) {
    var subgroup = f.call(self, d, i),
        r = radius.call(self, subgroup, i),
        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,
        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
    return {
      r: r,
      a0: a0,
      a1: a1,
      p0: [r * Math.cos(a0), r * Math.sin(a0)],
      p1: [r * Math.cos(a1), r * Math.sin(a1)]
    };
  }

  function equals(a, b) {
    return a.a0 == b.a0 &amp;&amp; a.a1 == b.a1;
  }

  function arc(r, p, a) {
    return &quot;A&quot; + r + &quot;,&quot; + r + &quot; 0 &quot; + +(a &gt; Math.PI) + &quot;,1 &quot; + p;
  }

  function curve(r0, p0, r1, p1) {
    return &quot;Q 0,0 &quot; + p1;
  }

  chord.radius = function(v) {
    if (!arguments.length) return radius;
    radius = d3.functor(v);
    return chord;
  };

  chord.source = function(v) {
    if (!arguments.length) return source;
    source = d3.functor(v);
    return chord;
  };

  chord.target = function(v) {
    if (!arguments.length) return target;
    target = d3.functor(v);
    return chord;
  };

  chord.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3.functor(v);
    return chord;
  };

  chord.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3.functor(v);
    return chord;
  };

  return chord;
};

function d3_svg_chordSource(d) {
  return d.source;
}

function d3_svg_chordTarget(d) {
  return d.target;
}

function d3_svg_chordRadius(d) {
  return d.radius;
}

function d3_svg_chordStartAngle(d) {
  return d.startAngle;
}

function d3_svg_chordEndAngle(d) {
  return d.endAngle;
}
d3.svg.diagonal = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      projection = d3_svg_diagonalProjection;

  function diagonal(d, i) {
    var p0 = source.call(this, d, i),
        p3 = target.call(this, d, i),
        m = (p0.y + p3.y) / 2,
        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];
    p = p.map(projection);
    return &quot;M&quot; + p[0] + &quot;C&quot; + p[1] + &quot; &quot; + p[2] + &quot; &quot; + p[3];
  }

  diagonal.source = function(x) {
    if (!arguments.length) return source;
    source = d3.functor(x);
    return diagonal;
  };

  diagonal.target = function(x) {
    if (!arguments.length) return target;
    target = d3.functor(x);
    return diagonal;
  };

  diagonal.projection = function(x) {
    if (!arguments.length) return projection;
    projection = x;
    return diagonal;
  };

  return diagonal;
};

function d3_svg_diagonalProjection(d) {
  return [d.x, d.y];
}
d3.svg.diagonal.radial = function() {
  var diagonal = d3.svg.diagonal(),
      projection = d3_svg_diagonalProjection,
      projection_ = diagonal.projection;

  diagonal.projection = function(x) {
    return arguments.length
        ? projection_(d3_svg_diagonalRadialProjection(projection = x))
        : projection;
  };

  return diagonal;
};

function d3_svg_diagonalRadialProjection(projection) {
  return function() {
    var d = projection.apply(this, arguments),
        r = d[0],
        a = d[1] + d3_svg_arcOffset;
    return [r * Math.cos(a), r * Math.sin(a)];
  };
}
d3.svg.mouse = function(container) {
  return d3_svg_mousePoint(container, d3.event);
};

// https://bugs.webkit.org/show_bug.cgi?id=44083
var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;

function d3_svg_mousePoint(container, e) {
  var point = (container.ownerSVGElement || container).createSVGPoint();
  if ((d3_mouse_bug44083 &lt; 0) &amp;&amp; (window.scrollX || window.scrollY)) {
    var svg = d3.select(document.body)
      .append(&quot;svg&quot;)
        .style(&quot;position&quot;, &quot;absolute&quot;)
        .style(&quot;top&quot;, 0)
        .style(&quot;left&quot;, 0);
    var ctm = svg[0][0].getScreenCTM();
    d3_mouse_bug44083 = !(ctm.f || ctm.e);
    svg.remove();
  }
  if (d3_mouse_bug44083) {
    point.x = e.pageX;
    point.y = e.pageY;
  } else {
    point.x = e.clientX;
    point.y = e.clientY;
  }
  point = point.matrixTransform(container.getScreenCTM().inverse());
  return [point.x, point.y];
};
d3.svg.touches = function(container, touches) {
  if (arguments.length &lt; 2) touches = d3.event.touches;

  return touches ? d3_array(touches).map(function(touch) {
    var point = d3_svg_mousePoint(container, touch);
    point.identifier = touch.identifier;
    return point;
  }) : [];
};
d3.svg.symbol = function() {
  var type = d3_svg_symbolType,
      size = d3_svg_symbolSize;

  function symbol(d, i) {
    return (d3_svg_symbols[type.call(this, d, i)]
        || d3_svg_symbols.circle)
        (size.call(this, d, i));
  }

  symbol.type = function(x) {
    if (!arguments.length) return type;
    type = d3.functor(x);
    return symbol;
  };

  // size of symbol in square pixels
  symbol.size = function(x) {
    if (!arguments.length) return size;
    size = d3.functor(x);
    return symbol;
  };

  return symbol;
};

function d3_svg_symbolSize() {
  return 64;
}

function d3_svg_symbolType() {
  return &quot;circle&quot;;
}

// TODO cross-diagonal?
var d3_svg_symbols = {
  &quot;circle&quot;: function(size) {
    var r = Math.sqrt(size / Math.PI);
    return &quot;M0,&quot; + r
        + &quot;A&quot; + r + &quot;,&quot; + r + &quot; 0 1,1 0,&quot; + (-r)
        + &quot;A&quot; + r + &quot;,&quot; + r + &quot; 0 1,1 0,&quot; + r
        + &quot;Z&quot;;
  },
  &quot;cross&quot;: function(size) {
    var r = Math.sqrt(size / 5) / 2;
    return &quot;M&quot; + -3 * r + &quot;,&quot; + -r
        + &quot;H&quot; + -r
        + &quot;V&quot; + -3 * r
        + &quot;H&quot; + r
        + &quot;V&quot; + -r
        + &quot;H&quot; + 3 * r
        + &quot;V&quot; + r
        + &quot;H&quot; + r
        + &quot;V&quot; + 3 * r
        + &quot;H&quot; + -r
        + &quot;V&quot; + r
        + &quot;H&quot; + -3 * r
        + &quot;Z&quot;;
  },
  &quot;diamond&quot;: function(size) {
    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
        rx = ry * d3_svg_symbolTan30;
    return &quot;M0,&quot; + -ry
        + &quot;L&quot; + rx + &quot;,0&quot;
        + &quot; 0,&quot; + ry
        + &quot; &quot; + -rx + &quot;,0&quot;
        + &quot;Z&quot;;
  },
  &quot;square&quot;: function(size) {
    var r = Math.sqrt(size) / 2;
    return &quot;M&quot; + -r + &quot;,&quot; + -r
        + &quot;L&quot; + r + &quot;,&quot; + -r
        + &quot; &quot; + r + &quot;,&quot; + r
        + &quot; &quot; + -r + &quot;,&quot; + r
        + &quot;Z&quot;;
  },
  &quot;triangle-down&quot;: function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return &quot;M0,&quot; + ry
        + &quot;L&quot; + rx +&quot;,&quot; + -ry
        + &quot; &quot; + -rx + &quot;,&quot; + -ry
        + &quot;Z&quot;;
  },
  &quot;triangle-up&quot;: function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return &quot;M0,&quot; + -ry
        + &quot;L&quot; + rx +&quot;,&quot; + ry
        + &quot; &quot; + -rx + &quot;,&quot; + ry
        + &quot;Z&quot;;
  }
};

d3.svg.symbolTypes = d3.keys(d3_svg_symbols);

var d3_svg_symbolSqrt3 = Math.sqrt(3),
    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);
d3.svg.axis = function() {
  var scale = d3.scale.linear(),
      orient = &quot;bottom&quot;,
      tickMajorSize = 6,
      tickMinorSize = 6,
      tickEndSize = 6,
      tickPadding = 3,
      tickArguments_ = [10],
      tickFormat_,
      tickSubdivide = 0;

  function axis(selection) {
    selection.each(function(d, i, j) {
      var g = d3.select(this);

      // If selection is a transition, create subtransitions.
      var transition = selection.delay ? function(o) {
        var id = d3_transitionInheritId;
        try {
          d3_transitionInheritId = selection.id;
          return o.transition()
              .delay(selection[j][i].delay)
              .duration(selection[j][i].duration)
              .ease(selection.ease());
        } finally {
          d3_transitionInheritId = id;
        }
      } : Object;

      // Ticks, or domain values for ordinal scales.
      var ticks = scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain(),
          tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_;

      // Minor ticks.
      var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),
          subtick = g.selectAll(&quot;.minor&quot;).data(subticks, String),
          subtickEnter = subtick.enter().insert(&quot;line&quot;, &quot;g&quot;).attr(&quot;class&quot;, &quot;tick minor&quot;).style(&quot;opacity&quot;, 1e-6),
          subtickExit = transition(subtick.exit()).style(&quot;opacity&quot;, 1e-6).remove(),
          subtickUpdate = transition(subtick).style(&quot;opacity&quot;, 1);

      // Major ticks.
      var tick = g.selectAll(&quot;g&quot;).data(ticks, String),
          tickEnter = tick.enter().insert(&quot;g&quot;, &quot;path&quot;).style(&quot;opacity&quot;, 1e-6),
          tickExit = transition(tick.exit()).style(&quot;opacity&quot;, 1e-6).remove(),
          tickUpdate = transition(tick).style(&quot;opacity&quot;, 1),
          tickTransform;

      // Domain.
      var range = d3_scaleRange(scale),
          path = g.selectAll(&quot;.domain&quot;).data([0]),
          pathEnter = path.enter().append(&quot;path&quot;).attr(&quot;class&quot;, &quot;domain&quot;),
          pathUpdate = transition(path);

      // Stash a snapshot of the new scale, and retrieve the old snapshot.
      var scale1 = scale.copy(),
          scale0 = this.__chart__ || scale1;
      this.__chart__ = scale1;

      tickEnter.append(&quot;line&quot;).attr(&quot;class&quot;, &quot;tick&quot;);
      tickEnter.append(&quot;text&quot;);
      tickUpdate.select(&quot;text&quot;).text(tickFormat);

      switch (orient) {
        case &quot;bottom&quot;: {
          tickTransform = d3_svg_axisX;
          subtickEnter.attr(&quot;y2&quot;, tickMinorSize);
          subtickUpdate.attr(&quot;x2&quot;, 0).attr(&quot;y2&quot;, tickMinorSize);
          tickEnter.select(&quot;line&quot;).attr(&quot;y2&quot;, tickMajorSize);
          tickEnter.select(&quot;text&quot;).attr(&quot;y&quot;, Math.max(tickMajorSize, 0) + tickPadding);
          tickUpdate.select(&quot;line&quot;).attr(&quot;x2&quot;, 0).attr(&quot;y2&quot;, tickMajorSize);
          tickUpdate.select(&quot;text&quot;).attr(&quot;x&quot;, 0).attr(&quot;y&quot;, Math.max(tickMajorSize, 0) + tickPadding).attr(&quot;dy&quot;, &quot;.71em&quot;).attr(&quot;text-anchor&quot;, &quot;middle&quot;);
          pathUpdate.attr(&quot;d&quot;, &quot;M&quot; + range[0] + &quot;,&quot; + tickEndSize + &quot;V0H&quot; + range[1] + &quot;V&quot; + tickEndSize);
          break;
        }
        case &quot;top&quot;: {
          tickTransform = d3_svg_axisX;
          subtickEnter.attr(&quot;y2&quot;, -tickMinorSize);
          subtickUpdate.attr(&quot;x2&quot;, 0).attr(&quot;y2&quot;, -tickMinorSize);
          tickEnter.select(&quot;line&quot;).attr(&quot;y2&quot;, -tickMajorSize);
          tickEnter.select(&quot;text&quot;).attr(&quot;y&quot;, -(Math.max(tickMajorSize, 0) + tickPadding));
          tickUpdate.select(&quot;line&quot;).attr(&quot;x2&quot;, 0).attr(&quot;y2&quot;, -tickMajorSize);
          tickUpdate.select(&quot;text&quot;).attr(&quot;x&quot;, 0).attr(&quot;y&quot;, -(Math.max(tickMajorSize, 0) + tickPadding)).attr(&quot;dy&quot;, &quot;0em&quot;).attr(&quot;text-anchor&quot;, &quot;middle&quot;);
          pathUpdate.attr(&quot;d&quot;, &quot;M&quot; + range[0] + &quot;,&quot; + -tickEndSize + &quot;V0H&quot; + range[1] + &quot;V&quot; + -tickEndSize);
          break;
        }
        case &quot;left&quot;: {
          tickTransform = d3_svg_axisY;
          subtickEnter.attr(&quot;x2&quot;, -tickMinorSize);
          subtickUpdate.attr(&quot;x2&quot;, -tickMinorSize).attr(&quot;y2&quot;, 0);
          tickEnter.select(&quot;line&quot;).attr(&quot;x2&quot;, -tickMajorSize);
          tickEnter.select(&quot;text&quot;).attr(&quot;x&quot;, -(Math.max(tickMajorSize, 0) + tickPadding));
          tickUpdate.select(&quot;line&quot;).attr(&quot;x2&quot;, -tickMajorSize).attr(&quot;y2&quot;, 0);
          tickUpdate.select(&quot;text&quot;).attr(&quot;x&quot;, -(Math.max(tickMajorSize, 0) + tickPadding)).attr(&quot;y&quot;, 0).attr(&quot;dy&quot;, &quot;.32em&quot;).attr(&quot;text-anchor&quot;, &quot;end&quot;);
          pathUpdate.attr(&quot;d&quot;, &quot;M&quot; + -tickEndSize + &quot;,&quot; + range[0] + &quot;H0V&quot; + range[1] + &quot;H&quot; + -tickEndSize);
          break;
        }
        case &quot;right&quot;: {
          tickTransform = d3_svg_axisY;
          subtickEnter.attr(&quot;x2&quot;, tickMinorSize);
          subtickUpdate.attr(&quot;x2&quot;, tickMinorSize).attr(&quot;y2&quot;, 0);
          tickEnter.select(&quot;line&quot;).attr(&quot;x2&quot;, tickMajorSize);
          tickEnter.select(&quot;text&quot;).attr(&quot;x&quot;, Math.max(tickMajorSize, 0) + tickPadding);
          tickUpdate.select(&quot;line&quot;).attr(&quot;x2&quot;, tickMajorSize).attr(&quot;y2&quot;, 0);
          tickUpdate.select(&quot;text&quot;).attr(&quot;x&quot;, Math.max(tickMajorSize, 0) + tickPadding).attr(&quot;y&quot;, 0).attr(&quot;dy&quot;, &quot;.32em&quot;).attr(&quot;text-anchor&quot;, &quot;start&quot;);
          pathUpdate.attr(&quot;d&quot;, &quot;M&quot; + tickEndSize + &quot;,&quot; + range[0] + &quot;H0V&quot; + range[1] + &quot;H&quot; + tickEndSize);
          break;
        }
      }

      // For quantitative scales:
      // - enter new ticks from the old scale
      // - exit old ticks to the new scale
      if (scale.ticks) {
        tickEnter.call(tickTransform, scale0);
        tickUpdate.call(tickTransform, scale1);
        tickExit.call(tickTransform, scale1);
        subtickEnter.call(tickTransform, scale0);
        subtickUpdate.call(tickTransform, scale1);
        subtickExit.call(tickTransform, scale1);
      }

      // For ordinal scales:
      // - any entering ticks are undefined in the old scale
      // - any exiting ticks are undefined in the new scale
      // Therefore, we only need to transition updating ticks.
      else {
        var dx = scale1.rangeBand() / 2, x = function(d) { return scale1(d) + dx; };
        tickEnter.call(tickTransform, x);
        tickUpdate.call(tickTransform, x);
      }
    });
  }

  axis.scale = function(x) {
    if (!arguments.length) return scale;
    scale = x;
    return axis;
  };

  axis.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x;
    return axis;
  };

  axis.ticks = function() {
    if (!arguments.length) return tickArguments_;
    tickArguments_ = arguments;
    return axis;
  };

  axis.tickFormat = function(x) {
    if (!arguments.length) return tickFormat_;
    tickFormat_ = x;
    return axis;
  };

  axis.tickSize = function(x, y, z) {
    if (!arguments.length) return tickMajorSize;
    var n = arguments.length - 1;
    tickMajorSize = +x;
    tickMinorSize = n &gt; 1 ? +y : tickMajorSize;
    tickEndSize = n &gt; 0 ? +arguments[n] : tickMajorSize;
    return axis;
  };

  axis.tickPadding = function(x) {
    if (!arguments.length) return tickPadding;
    tickPadding = +x;
    return axis;
  };

  axis.tickSubdivide = function(x) {
    if (!arguments.length) return tickSubdivide;
    tickSubdivide = +x;
    return axis;
  };

  return axis;
};

function d3_svg_axisX(selection, x) {
  selection.attr(&quot;transform&quot;, function(d) { return &quot;translate(&quot; + x(d) + &quot;,0)&quot;; });
}

function d3_svg_axisY(selection, y) {
  selection.attr(&quot;transform&quot;, function(d) { return &quot;translate(0,&quot; + y(d) + &quot;)&quot;; });
}

function d3_svg_axisSubdivide(scale, ticks, m) {
  subticks = [];
  if (m &amp;&amp; ticks.length &gt; 1) {
    var extent = d3_scaleExtent(scale.domain()),
        subticks,
        i = -1,
        n = ticks.length,
        d = (ticks[1] - ticks[0]) / ++m,
        j,
        v;
    while (++i &lt; n) {
      for (j = m; --j &gt; 0;) {
        if ((v = +ticks[i] - j * d) &gt;= extent[0]) {
          subticks.push(v);
        }
      }
    }
    for (--i, j = 0; ++j &lt; m &amp;&amp; (v = +ticks[i] + j * d) &lt; extent[1];) {
      subticks.push(v);
    }
  }
  return subticks;
}
d3.svg.brush = function() {
  var event = d3.dispatch(&quot;brushstart&quot;, &quot;brush&quot;, &quot;brushend&quot;),
      x, // x-scale, optional
      y, // y-scale, optional
      extent = [[0, 0], [0, 0]]; // [x0, y0], [x1, y1]

  function brush(g) {
    var resizes = x &amp;&amp; y ? [&quot;n&quot;, &quot;e&quot;, &quot;s&quot;, &quot;w&quot;, &quot;nw&quot;, &quot;ne&quot;, &quot;se&quot;, &quot;sw&quot;]
        : x ? [&quot;e&quot;, &quot;w&quot;]
        : y ? [&quot;n&quot;, &quot;s&quot;]
        : [];

    g.each(function() {
      var g = d3.select(this).on(&quot;mousedown.brush&quot;, down),
          bg = g.selectAll(&quot;.background&quot;).data([0]),
          fg = g.selectAll(&quot;.extent&quot;).data([0]),
          tz = g.selectAll(&quot;.resize&quot;).data(resizes, String),
          e;

      // An invisible, mouseable area for starting a new brush.
      bg.enter().append(&quot;rect&quot;)
          .attr(&quot;class&quot;, &quot;background&quot;)
          .style(&quot;visibility&quot;, &quot;hidden&quot;)
          .style(&quot;pointer-events&quot;, &quot;all&quot;)
          .style(&quot;cursor&quot;, &quot;crosshair&quot;);

      // The visible brush extent; style this as you like!
      fg.enter().append(&quot;rect&quot;)
          .attr(&quot;class&quot;, &quot;extent&quot;)
          .style(&quot;cursor&quot;, &quot;move&quot;);

      // More invisible rects for resizing the extent.
      tz.enter().append(&quot;rect&quot;)
          .attr(&quot;class&quot;, function(d) { return &quot;resize &quot; + d; })
          .attr(&quot;width&quot;, 6)
          .attr(&quot;height&quot;, 6)
          .style(&quot;visibility&quot;, &quot;hidden&quot;)
          .style(&quot;cursor&quot;, function(d) { return d3_svg_brushCursor[d]; });

      // Update the resizers.
      tz.style(&quot;pointer-events&quot;, brush.empty() ? &quot;none&quot; : &quot;all&quot;);

      // Remove any superfluous resizers.
      tz.exit().remove();

      // Initialize the background to fill the defined range.
      // If the range isn&#x27;t defined, you can post-process.
      if (x) {
        e = d3_scaleRange(x);
        bg.attr(&quot;x&quot;, e[0]).attr(&quot;width&quot;, e[1] - e[0]);
        d3_svg_brushRedrawX(g, extent);
      }
      if (y) {
        e = d3_scaleRange(y);
        bg.attr(&quot;y&quot;, e[0]).attr(&quot;height&quot;, e[1] - e[0]);
        d3_svg_brushRedrawY(g, extent);
      }
    });
  }

  function down() {
    var target = d3.select(d3.event.target);

    // Store some global state for the duration of the brush gesture.
    d3_svg_brush = brush;
    d3_svg_brushTarget = this;
    d3_svg_brushExtent = extent;
    d3_svg_brushOffset = d3.svg.mouse(d3_svg_brushTarget);

    // If the extent was clicked on, drag rather than brush;
    // store the offset between the mouse and extent origin instead.
    if (d3_svg_brushDrag = target.classed(&quot;extent&quot;)) {
      d3_svg_brushOffset[0] = extent[0][0] - d3_svg_brushOffset[0];
      d3_svg_brushOffset[1] = extent[0][1] - d3_svg_brushOffset[1];
    }

    // If a resizer was clicked on, record which side is to be resized.
    // Also, set the offset to the opposite side.
    else if (target.classed(&quot;resize&quot;)) {
      d3_svg_brushResize = d3.event.target.__data__;
      d3_svg_brushOffset[0] = extent[+/w$/.test(d3_svg_brushResize)][0];
      d3_svg_brushOffset[1] = extent[+/^n/.test(d3_svg_brushResize)][1];
    }

    // If the ALT key is down when starting a brush, the center is at the mouse.
    else if (d3.event.altKey) {
      d3_svg_brushCenter = d3_svg_brushOffset.slice();
    }

    // Restrict which dimensions are resized.
    d3_svg_brushX = !/^(n|s)$/.test(d3_svg_brushResize) &amp;&amp; x;
    d3_svg_brushY = !/^(e|w)$/.test(d3_svg_brushResize) &amp;&amp; y;

    // Notify listeners.
    d3_svg_brushDispatch = dispatcher(this, arguments);
    d3_svg_brushDispatch(&quot;brushstart&quot;);
    d3_svg_brushMove();
    d3_eventCancel();
  }

  function dispatcher(that, argumentz) {
    return function(type) {
      var e = d3.event;
      try {
        d3.event = {type: type, target: brush};
        event[type].apply(that, argumentz);
      } finally {
        d3.event = e;
      }
    };
  }

  brush.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    return brush;
  };

  brush.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    return brush;
  };

  brush.extent = function(z) {
    var x0, x1, y0, y1, t;

    // Invert the pixel extent to data-space.
    if (!arguments.length) {
      if (x) {
        x0 = extent[0][0], x1 = extent[1][0];
        if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
        if (x1 &lt; x0) t = x0, x0 = x1, x1 = t;
      }
      if (y) {
        y0 = extent[0][1], y1 = extent[1][1];
        if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
        if (y1 &lt; y0) t = y0, y0 = y1, y1 = t;
      }
      return x &amp;&amp; y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y &amp;&amp; [y0, y1];
    }

    // Scale the data-space extent to pixels.
    if (x) {
      x0 = z[0], x1 = z[1];
      if (y) x0 = x0[0], x1 = x1[0];
      if (x.invert) x0 = x(x0), x1 = x(x1);
      if (x1 &lt; x0) t = x0, x0 = x1, x1 = t;
      extent[0][0] = x0, extent[1][0] = x1;
    }
    if (y) {
      y0 = z[0], y1 = z[1];
      if (x) y0 = y0[1], y1 = y1[1];
      if (y.invert) y0 = y(y0), y1 = y(y1);
      if (y1 &lt; y0) t = y0, y0 = y1, y1 = t;
      extent[0][1] = y0, extent[1][1] = y1;
    }

    return brush;
  };

  brush.clear = function() {
    extent[0][0] =
    extent[0][1] =
    extent[1][0] =
    extent[1][1] = 0;
    return brush;
  };

  brush.empty = function() {
    return (x &amp;&amp; extent[0][0] === extent[1][0])
        || (y &amp;&amp; extent[0][1] === extent[1][1]);
  };

  d3.select(window)
      .on(&quot;mousemove.brush&quot;, d3_svg_brushMove)
      .on(&quot;mouseup.brush&quot;, d3_svg_brushUp)
      .on(&quot;keydown.brush&quot;, d3_svg_brushKeydown)
      .on(&quot;keyup.brush&quot;, d3_svg_brushKeyup);

  return d3.rebind(brush, event, &quot;on&quot;);
};

var d3_svg_brush,
    d3_svg_brushDispatch,
    d3_svg_brushTarget,
    d3_svg_brushX,
    d3_svg_brushY,
    d3_svg_brushExtent,
    d3_svg_brushDrag,
    d3_svg_brushResize,
    d3_svg_brushCenter,
    d3_svg_brushOffset;

function d3_svg_brushRedrawX(g, extent) {
  g.select(&quot;.extent&quot;).attr(&quot;x&quot;, extent[0][0]);
  g.selectAll(&quot;.n,.s,.w,.nw,.sw&quot;).attr(&quot;x&quot;, extent[0][0] - 2);
  g.selectAll(&quot;.e,.ne,.se&quot;).attr(&quot;x&quot;, extent[1][0] - 3);
  g.selectAll(&quot;.extent,.n,.s&quot;).attr(&quot;width&quot;, extent[1][0] - extent[0][0]);
}

function d3_svg_brushRedrawY(g, extent) {
  g.select(&quot;.extent&quot;).attr(&quot;y&quot;, extent[0][1]);
  g.selectAll(&quot;.n,.e,.w,.nw,.ne&quot;).attr(&quot;y&quot;, extent[0][1] - 3);
  g.selectAll(&quot;.s,.se,.sw&quot;).attr(&quot;y&quot;, extent[1][1] - 4);
  g.selectAll(&quot;.extent,.e,.w&quot;).attr(&quot;height&quot;, extent[1][1] - extent[0][1]);
}

function d3_svg_brushKeydown() {
  if (d3.event.keyCode == 32 &amp;&amp; d3_svg_brushTarget &amp;&amp; !d3_svg_brushDrag) {
    d3_svg_brushCenter = null;
    d3_svg_brushOffset[0] -= d3_svg_brushExtent[1][0];
    d3_svg_brushOffset[1] -= d3_svg_brushExtent[1][1];
    d3_svg_brushDrag = 2;
    d3_eventCancel();
  }
}

function d3_svg_brushKeyup() {
  if (d3.event.keyCode == 32 &amp;&amp; d3_svg_brushDrag == 2) {
    d3_svg_brushOffset[0] += d3_svg_brushExtent[1][0];
    d3_svg_brushOffset[1] += d3_svg_brushExtent[1][1];
    d3_svg_brushDrag = 0;
    d3_eventCancel();
  }
}

function d3_svg_brushMove() {
  if (d3_svg_brushOffset) {
    var mouse = d3.svg.mouse(d3_svg_brushTarget),
        g = d3.select(d3_svg_brushTarget);

    if (!d3_svg_brushDrag) {

      // If needed, determine the center from the current extent.
      if (d3.event.altKey) {
        if (!d3_svg_brushCenter) {
          d3_svg_brushCenter = [
            (d3_svg_brushExtent[0][0] + d3_svg_brushExtent[1][0]) / 2,
            (d3_svg_brushExtent[0][1] + d3_svg_brushExtent[1][1]) / 2
          ];
        }

        // Update the offset, for when the ALT key is released.
        d3_svg_brushOffset[0] = d3_svg_brushExtent[+(mouse[0] &lt; d3_svg_brushCenter[0])][0];
        d3_svg_brushOffset[1] = d3_svg_brushExtent[+(mouse[1] &lt; d3_svg_brushCenter[1])][1];
      }

      // When the ALT key is released, we clear the center.
      else d3_svg_brushCenter = null;
    }

    // Update the brush extent for each dimension.
    if (d3_svg_brushX) {
      d3_svg_brushMove1(mouse, d3_svg_brushX, 0);
      d3_svg_brushRedrawX(g, d3_svg_brushExtent);
    }
    if (d3_svg_brushY) {
      d3_svg_brushMove1(mouse, d3_svg_brushY, 1);
      d3_svg_brushRedrawY(g, d3_svg_brushExtent);
    }

    // Notify listeners.
    d3_svg_brushDispatch(&quot;brush&quot;);
  }
}

function d3_svg_brushMove1(mouse, scale, i) {
  var range = d3_scaleRange(scale),
      r0 = range[0],
      r1 = range[1],
      offset = d3_svg_brushOffset[i],
      size = d3_svg_brushExtent[1][i] - d3_svg_brushExtent[0][i],
      min,
      max;

  // When dragging, reduce the range by the extent size and offset.
  if (d3_svg_brushDrag) {
    r0 -= offset;
    r1 -= size + offset;
  }

  // Clamp the mouse so that the extent fits within the range extent.
  min = Math.max(r0, Math.min(r1, mouse[i]));

  // Compute the new extent bounds.
  if (d3_svg_brushDrag) {
    max = (min += offset) + size;
  } else {

    // If the ALT key is pressed, then preserve the center of the extent.
    if (d3_svg_brushCenter) offset = Math.max(r0, Math.min(r1, 2 * d3_svg_brushCenter[i] - min));

    // Compute the min and max of the offset and mouse.
    if (offset &lt; min) {
      max = min;
      min = offset;
    } else {
      max = offset;
    }
  }

  // Update the stored bounds.
  d3_svg_brushExtent[0][i] = min;
  d3_svg_brushExtent[1][i] = max;
}

function d3_svg_brushUp() {
  if (d3_svg_brushOffset) {
    d3_svg_brushMove();
    d3.select(d3_svg_brushTarget).selectAll(&quot;.resize&quot;).style(&quot;pointer-events&quot;, d3_svg_brush.empty() ? &quot;none&quot; : &quot;all&quot;);
    d3_svg_brushDispatch(&quot;brushend&quot;);
    d3_svg_brush =
    d3_svg_brushDispatch =
    d3_svg_brushTarget =
    d3_svg_brushX =
    d3_svg_brushY =
    d3_svg_brushExtent =
    d3_svg_brushDrag =
    d3_svg_brushResize =
    d3_svg_brushCenter =
    d3_svg_brushOffset = null;
    d3_eventCancel();
  }
}

var d3_svg_brushCursor = {
  n: &quot;ns-resize&quot;,
  e: &quot;ew-resize&quot;,
  s: &quot;ns-resize&quot;,
  w: &quot;ew-resize&quot;,
  nw: &quot;nwse-resize&quot;,
  ne: &quot;nesw-resize&quot;,
  se: &quot;nwse-resize&quot;,
  sw: &quot;nesw-resize&quot;
};
d3.behavior = {};
// TODO Track touch points by identifier.

d3.behavior.drag = function() {
  var event = d3.dispatch(&quot;drag&quot;, &quot;dragstart&quot;, &quot;dragend&quot;),
      origin = null;

  function drag() {
    this
        .on(&quot;mousedown.drag&quot;, mousedown)
        .on(&quot;touchstart.drag&quot;, mousedown);

    d3.select(window)
        .on(&quot;mousemove.drag&quot;, d3_behavior_dragMove)
        .on(&quot;touchmove.drag&quot;, d3_behavior_dragMove)
        .on(&quot;mouseup.drag&quot;, d3_behavior_dragUp, true)
        .on(&quot;touchend.drag&quot;, d3_behavior_dragUp, true)
        .on(&quot;click.drag&quot;, d3_behavior_dragClick, true);
  }

  // snapshot the local context for subsequent dispatch
  function start() {
    d3_behavior_dragEvent = event;
    d3_behavior_dragEventTarget = d3.event.target;
    d3_behavior_dragTarget = this;
    d3_behavior_dragArguments = arguments;
    d3_behavior_dragOrigin = d3_behavior_dragPoint();
    if (origin) {
      d3_behavior_dragOffset = origin.apply(d3_behavior_dragTarget, d3_behavior_dragArguments);
      d3_behavior_dragOffset = [d3_behavior_dragOffset.x - d3_behavior_dragOrigin[0], d3_behavior_dragOffset.y - d3_behavior_dragOrigin[1]];
    } else {
      d3_behavior_dragOffset = [0, 0];
    }
    d3_behavior_dragMoved = 0;
  }

  function mousedown() {
    start.apply(this, arguments);
    d3_behavior_dragDispatch(&quot;dragstart&quot;);
  }

  drag.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    return drag;
  };

  return d3.rebind(drag, event, &quot;on&quot;);
};

var d3_behavior_dragEvent,
    d3_behavior_dragEventTarget,
    d3_behavior_dragTarget,
    d3_behavior_dragArguments,
    d3_behavior_dragOffset,
    d3_behavior_dragOrigin,
    d3_behavior_dragMoved;

function d3_behavior_dragDispatch(type) {
  var p = d3_behavior_dragPoint(),
      o = d3.event,
      e = d3.event = {type: type};

  if (p) {
    e.x = p[0] + d3_behavior_dragOffset[0];
    e.y = p[1] + d3_behavior_dragOffset[1];
    e.dx = p[0] - d3_behavior_dragOrigin[0];
    e.dy = p[1] - d3_behavior_dragOrigin[1];
    d3_behavior_dragMoved |= e.dx | e.dy;
    d3_behavior_dragOrigin = p;
  }

  try {
    d3_behavior_dragEvent[type].apply(d3_behavior_dragTarget, d3_behavior_dragArguments);
  } finally {
    d3.event = o;
  }

  o.stopPropagation();
  o.preventDefault();
}

function d3_behavior_dragPoint() {
  var p = d3_behavior_dragTarget.parentNode,
      t = d3.event.changedTouches;
  return p &amp;&amp; (t
      ? d3.svg.touches(p, t)[0]
      : d3.svg.mouse(p));
}

function d3_behavior_dragMove() {
  if (!d3_behavior_dragTarget) return;
  var parent = d3_behavior_dragTarget.parentNode;

  // O NOES! The drag element was removed from the DOM.
  if (!parent) return d3_behavior_dragUp();

  d3_behavior_dragDispatch(&quot;drag&quot;);
  d3_eventCancel();
}

function d3_behavior_dragUp() {
  if (!d3_behavior_dragTarget) return;
  d3_behavior_dragDispatch(&quot;dragend&quot;);

  // If the node was moved, prevent the mouseup from propagating.
  // Also prevent the subsequent click from propagating (e.g., for anchors).
  if (d3_behavior_dragMoved) {
    d3_eventCancel();
    d3_behavior_dragMoved = d3.event.target === d3_behavior_dragEventTarget;
  }

  d3_behavior_dragEvent =
  d3_behavior_dragEventTarget =
  d3_behavior_dragTarget =
  d3_behavior_dragArguments =
  d3_behavior_dragOffset =
  d3_behavior_dragOrigin = null;
}

function d3_behavior_dragClick() {
  if (d3_behavior_dragMoved) {
    d3_eventCancel();
    d3_behavior_dragMoved = 0;
  }
}
// TODO unbind zoom behavior?
d3.behavior.zoom = function() {
  var xyz = [0, 0, 0],
      event = d3.dispatch(&quot;zoom&quot;),
      extent = d3_behavior_zoomInfiniteExtent;

  function zoom() {
    this
        .on(&quot;mousedown.zoom&quot;, mousedown)
        .on(&quot;mousewheel.zoom&quot;, mousewheel)
        .on(&quot;DOMMouseScroll.zoom&quot;, mousewheel)
        .on(&quot;dblclick.zoom&quot;, dblclick)
        .on(&quot;touchstart.zoom&quot;, touchstart);

    d3.select(window)
        .on(&quot;mousemove.zoom&quot;, d3_behavior_zoomMousemove)
        .on(&quot;mouseup.zoom&quot;, d3_behavior_zoomMouseup)
        .on(&quot;touchmove.zoom&quot;, d3_behavior_zoomTouchmove)
        .on(&quot;touchend.zoom&quot;, d3_behavior_zoomTouchup)
        .on(&quot;click.zoom&quot;, d3_behavior_zoomClick, true);
  }

  // snapshot the local context for subsequent dispatch
  function start() {
    d3_behavior_zoomXyz = xyz;
    d3_behavior_zoomExtent = extent;
    d3_behavior_zoomDispatch = event.zoom;
    d3_behavior_zoomEventTarget = d3.event.target;
    d3_behavior_zoomTarget = this;
    d3_behavior_zoomArguments = arguments;
  }

  function mousedown() {
    start.apply(this, arguments);
    d3_behavior_zoomPanning = d3_behavior_zoomLocation(d3.svg.mouse(d3_behavior_zoomTarget));
    d3_behavior_zoomMoved = 0;
    d3.event.preventDefault();
    window.focus();
  }

  // store starting mouse location
  function mousewheel() {
    start.apply(this, arguments);
    if (!d3_behavior_zoomZooming) d3_behavior_zoomZooming = d3_behavior_zoomLocation(d3.svg.mouse(d3_behavior_zoomTarget));
    d3_behavior_zoomTo(d3_behavior_zoomDelta() + xyz[2], d3.svg.mouse(d3_behavior_zoomTarget), d3_behavior_zoomZooming);
  }

  function dblclick() {
    start.apply(this, arguments);
    var mouse = d3.svg.mouse(d3_behavior_zoomTarget);
    d3_behavior_zoomTo(d3.event.shiftKey ? Math.ceil(xyz[2] - 1) : Math.floor(xyz[2] + 1), mouse, d3_behavior_zoomLocation(mouse));
  }

  // doubletap detection
  function touchstart() {
    start.apply(this, arguments);
    var touches = d3_behavior_zoomTouchup(),
        touch,
        now = Date.now();
    if ((touches.length === 1) &amp;&amp; (now - d3_behavior_zoomLast &lt; 300)) {
      d3_behavior_zoomTo(1 + Math.floor(xyz[2]), touch = touches[0], d3_behavior_zoomLocations[touch.identifier]);
    }
    d3_behavior_zoomLast = now;
  }

  zoom.extent = function(x) {
    if (!arguments.length) return extent;
    extent = x == null ? d3_behavior_zoomInfiniteExtent : x;
    return zoom;
  };

  return d3.rebind(zoom, event, &quot;on&quot;);
};

var d3_behavior_zoomDiv,
    d3_behavior_zoomPanning,
    d3_behavior_zoomZooming,
    d3_behavior_zoomLocations = {}, // identifier -&gt; location
    d3_behavior_zoomLast = 0,
    d3_behavior_zoomXyz,
    d3_behavior_zoomExtent,
    d3_behavior_zoomDispatch,
    d3_behavior_zoomEventTarget,
    d3_behavior_zoomTarget,
    d3_behavior_zoomArguments,
    d3_behavior_zoomMoved;

function d3_behavior_zoomLocation(point) {
  return [
    point[0] - d3_behavior_zoomXyz[0],
    point[1] - d3_behavior_zoomXyz[1],
    d3_behavior_zoomXyz[2]
  ];
}

// detect the pixels that would be scrolled by this wheel event
function d3_behavior_zoomDelta() {

  // mousewheel events are totally broken!
  // https://bugs.webkit.org/show_bug.cgi?id=40441
  // not only that, but Chrome and Safari differ in re. to acceleration!
  if (!d3_behavior_zoomDiv) {
    d3_behavior_zoomDiv = d3.select(&quot;body&quot;).append(&quot;div&quot;)
        .style(&quot;visibility&quot;, &quot;hidden&quot;)
        .style(&quot;top&quot;, 0)
        .style(&quot;height&quot;, 0)
        .style(&quot;width&quot;, 0)
        .style(&quot;overflow-y&quot;, &quot;scroll&quot;)
      .append(&quot;div&quot;)
        .style(&quot;height&quot;, &quot;2000px&quot;)
      .node().parentNode;
  }

  var e = d3.event, delta;
  try {
    d3_behavior_zoomDiv.scrollTop = 1000;
    d3_behavior_zoomDiv.dispatchEvent(e);
    delta = 1000 - d3_behavior_zoomDiv.scrollTop;
  } catch (error) {
    delta = e.wheelDelta || (-e.detail * 5);
  }

  return delta * .005;
}

// Note: Since we don&#x27;t rotate, it&#x27;s possible for the touches to become
// slightly detached from their original positions. Thus, we recompute the
// touch points on touchend as well as touchstart!
function d3_behavior_zoomTouchup() {
  var touches = d3.svg.touches(d3_behavior_zoomTarget),
      i = -1,
      n = touches.length,
      touch;
  while (++i &lt; n) d3_behavior_zoomLocations[(touch = touches[i]).identifier] = d3_behavior_zoomLocation(touch);
  return touches;
}

function d3_behavior_zoomTouchmove() {
  var touches = d3.svg.touches(d3_behavior_zoomTarget);
  switch (touches.length) {

    // single-touch pan
    case 1: {
      var touch = touches[0];
      d3_behavior_zoomTo(d3_behavior_zoomXyz[2], touch, d3_behavior_zoomLocations[touch.identifier]);
      break;
    }

    // double-touch pan + zoom
    case 2: {
      var p0 = touches[0],
          p1 = touches[1],
          p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2],
          l0 = d3_behavior_zoomLocations[p0.identifier],
          l1 = d3_behavior_zoomLocations[p1.identifier],
          l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2, l0[2]];
      d3_behavior_zoomTo(Math.log(d3.event.scale) / Math.LN2 + l0[2], p2, l2);
      break;
    }
  }
}

function d3_behavior_zoomMousemove() {
  d3_behavior_zoomZooming = null;
  if (d3_behavior_zoomPanning) {
    d3_behavior_zoomMoved = 1;
    d3_behavior_zoomTo(d3_behavior_zoomXyz[2], d3.svg.mouse(d3_behavior_zoomTarget), d3_behavior_zoomPanning);
  }
}

function d3_behavior_zoomMouseup() {
  if (d3_behavior_zoomPanning) {
    if (d3_behavior_zoomMoved) {
      d3_eventCancel();
      d3_behavior_zoomMoved = d3_behavior_zoomEventTarget === d3.event.target;
    }

    d3_behavior_zoomXyz =
    d3_behavior_zoomExtent =
    d3_behavior_zoomDispatch =
    d3_behavior_zoomEventTarget =
    d3_behavior_zoomTarget =
    d3_behavior_zoomArguments =
    d3_behavior_zoomPanning = null;
  }
}

function d3_behavior_zoomClick() {
  if (d3_behavior_zoomMoved) {
    d3_eventCancel();
    d3_behavior_zoomMoved = 0;
  }
}

function d3_behavior_zoomTo(z, x0, x1) {
  z = d3_behavior_zoomExtentClamp(z, 2);
  var j = Math.pow(2, d3_behavior_zoomXyz[2]),
      k = Math.pow(2, z),
      K = Math.pow(2, (d3_behavior_zoomXyz[2] = z) - x1[2]),
      x_ = d3_behavior_zoomXyz[0],
      y_ = d3_behavior_zoomXyz[1],
      x = d3_behavior_zoomXyz[0] = d3_behavior_zoomExtentClamp((x0[0] - x1[0] * K), 0, k),
      y = d3_behavior_zoomXyz[1] = d3_behavior_zoomExtentClamp((x0[1] - x1[1] * K), 1, k),
      o = d3.event; // Events can be reentrant (e.g., focus).

  d3.event = {
    scale: k,
    translate: [x, y],
    transform: function(sx, sy) {
      if (sx) transform(sx, x_, x);
      if (sy) transform(sy, y_, y);
    }
  };

  function transform(scale, a, b) {
    scale.domain(scale.range().map(function(v) { return scale.invert(((v - b) * j) / k + a); }));
  }

  try {
    d3_behavior_zoomDispatch.apply(d3_behavior_zoomTarget, d3_behavior_zoomArguments);
  } finally {
    d3.event = o;
  }

  o.preventDefault();
}

var d3_behavior_zoomInfiniteExtent = [
  [-Infinity, Infinity],
  [-Infinity, Infinity],
  [-Infinity, Infinity]
];

function d3_behavior_zoomExtentClamp(x, i, k) {
  var range = d3_behavior_zoomExtent[i],
      r0 = range[0],
      r1 = range[1];
  return arguments.length === 3
      ? Math.max(r1 * (r1 === Infinity ? -Infinity : 1 / k - 1),
        Math.min(r0 === -Infinity ? Infinity : r0, x / k)) * k
      : Math.max(r0, Math.min(r1, x));
}
})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
